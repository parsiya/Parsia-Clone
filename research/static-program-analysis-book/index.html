<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Static Program Analysis Notes</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=https://parsiya.io//clone.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://parsiya.io/favicon.png rel=icon><meta name=description content><meta name=keywords content="[Parsia Hakimian Parsiya infosec information security]"><meta name=author content="Parsia-Clone"><meta name=generator content="Hugo 0.123.4"><meta name=twitter:card content="summary"><meta name=twitter:title content="Static Program Analysis Notes"><meta name=twitter:description content="Reading the version dated February 10, 2022.
https://cs.au.dk/~amoeller/spa/
I am gonna copy/paste stuff from the PDF and then add my notes instead of writing digitally on the PDF because I think it will be better for distribution and searching.
Text from the book is in quotes. I am going to modify some of the quotes to make them smaller. This is not a critique of the text. I am just making it easier for ME to understand."><meta name=twitter:domain content="parsiya.io"><meta name=twitter:creator content="@CryptoGangsta"></head><body><header role=banner><hgroup><h1><a href=https://parsiya.io/>Parsia-Clone</a></h1><h2>'Documentation is a love letter that you write to your future self.' - Damian Conway</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://github.com/parsiya/Parsia-Clone>» Parsia-Clone on Github</option><option value=https://parsiya.net/categories/clone/>» How did I make this?</option><option value=https://parsiya.net>» My Main Website</option></select></fieldset><ul class=main-navigation><li><a href=https://github.com/parsiya/Parsia-Clone title="Parsia-Clone on Github" target=_blank rel="noopener noreferrer">Parsia-Clone on Github</a></li><li><a href=https://parsiya.net/categories/clone/ title="How did I make this?" target=_blank rel="noopener noreferrer">How did I make this?</a></li><li><a href=https://parsiya.net title="My Main Website" target=_blank rel="noopener noreferrer">My Main Website</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://parsiya.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>5 minute read
- <a class=label href=https://parsiya.io/categories/research/>Research</a></p><h1 class=entry-title>Static Program Analysis Notes</h1><a href=https://github.com/parsiya/Parsia-Clone/tree/main/research/static-program-analysis-book/index.md target=_blank>Github Link</a></header><div class=entry-content><nav id=TableOfContents><ul><li><a href=#preface>Preface</a></li><li><a href=#chapter-1-introduction>Chapter 1: Introduction</a></li><li><a href=#chapter-2-a-tiny-imperative-programming-language>Chapter 2: A Tiny Imperative Programming Language</a><ul><li><a href=#25-control-flow-graphs>2.5 Control Flow Graphs</a></li></ul></li><li><a href=#chapter-3-type-analysis>Chapter 3: Type Analysis</a></li><li><a href=#chapter-4-lattice-theory>Chapter 4: Lattice Theory</a></li></ul></nav><p>Reading the version dated <code>February 10, 2022</code>.</p><p><a href=https://cs.au.dk/~amoeller/spa/ target=_blank rel="noreferrer noopener">https://cs.au.dk/~amoeller/spa/</a></p><p>I am gonna copy/paste stuff from the PDF and then add my notes instead of
writing digitally on the PDF because I think it will be better for
distribution and searching.</p><p>Text from the book is in quotes. I am going to modify some of the quotes to make
them smaller. This is not a critique of the text. I am just making it easier for
ME to understand.</p><h1 id=preface>Preface
<a class=header-link href=#preface><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><blockquote><p>Static program analysis is the art of reasoning about the behavior of computer
programs without actually running them.</p></blockquote><blockquote><p>automated reasoning of software generally must involve approximation</p></blockquote><p>The <code>Halting Problem</code> strikes again.</p><blockquote><p>ensure high precision and efficiency to be practically useful.</p></blockquote><blockquote><p>nobody will use [our tool] ... if it reports many false positives or if it is
too slow to fit into real-world software development processes</p></blockquote><p>There's a case to be made for "slow" scans. We can run them out-of-band. Things
like weekly (or nightly) or per-version scans are also useful.</p><h1 id=chapter-1-introduction>Chapter 1: Introduction
<a class=header-link href=#chapter-1-introduction><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Uses of static analysis. I don't need to be convinced that static analysis is
needed.</p><p>Rice’s theorem: all interesting questions about the input/output behavior of
programs (written in Turing-complete programming languages) are undecidable.</p><blockquote><p>[it's] possible to build analysis tools that give useful answers for most
realistic programs.</p></blockquote><p><strong>Exercise 1.1</strong></p><p>The code (removed the argc check) so we can just paste it in a REPL.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>p,<span style=color:#719e07>*</span>q;
</span></span><span style=display:flex><span>  p <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>;
</span></span><span style=display:flex><span>  <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;%s&#34;</span>,p);   <span style=color:#586e75>// Just prints (null) in modern compilers, not a security issue
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>  q <span style=color:#719e07>=</span> (<span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>)<span style=color:#268bd2>malloc</span>(<span style=color:#2aa198>100</span>);
</span></span><span style=display:flex><span>  p <span style=color:#719e07>=</span> q;
</span></span><span style=display:flex><span>  <span style=color:#268bd2>free</span>(q);
</span></span><span style=display:flex><span>  <span style=color:#719e07>*</span>p <span style=color:#719e07>=</span> <span style=color:#2aa198>&#39;x&#39;</span>; <span style=color:#586e75>// Use-after-free but it&#39;s not an error by itself in this code
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;%s&#34;</span>,p); <span style=color:#586e75>// Adding this line will trigger the UAF
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>free</span>(p);  <span style=color:#586e75>// Double free
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>  p <span style=color:#719e07>=</span> (<span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>)<span style=color:#268bd2>malloc</span>(<span style=color:#2aa198>100</span>);
</span></span><span style=display:flex><span>  p <span style=color:#719e07>=</span> (<span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>)<span style=color:#268bd2>malloc</span>(<span style=color:#2aa198>100</span>); <span style=color:#586e75>// memory leak because we did not free(p) before the new malloc
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  q <span style=color:#719e07>=</span> p;    <span style=color:#586e75>// another memory leak? because we did not free(q) before reassigning it
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>strcat</span>(p,q);  <span style=color:#586e75>// Buffer overflow - strcat doesn&#39;t do any bounds check
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p><strong>End of Exercise 1.1</strong></p><blockquote><p>a program analyzer is sound if it never gives incorrect results (but it may
answer maybe).</p></blockquote><p>Does this mean we can call every static analysis tool <code>sound</code>? They could give
us false positives but also say "Well, that was a maybe."</p><blockquote><p>the notion of soundness depends on the intended application of the analysis
output</p></blockquote><p>So it depends on the app and its context.</p><blockquote><p>a verification tool is typically called sound if it never misses any errors of
the kinds it has been designed to detect, but it is allowed to produce
spurious warnings (also called false positives),</p></blockquote><p>OK. Then a static analysis tool is <code>sound</code> IF it has 100% recall (reports every
issue) with some false positives.</p><blockquote><p>an automated testing tool is called sound if all reported errors are genuine,
but it may miss errors.</p></blockquote><p>A sound automated testing tool must have 100% precision (no false positives).</p><blockquote><p>some static analysis problems are undecidable</p></blockquote><p><strong>skipped 1.3</strong></p><h1 id=chapter-2-a-tiny-imperative-programming-language>Chapter 2: A Tiny Imperative Programming Language
<a class=header-link href=#chapter-2-a-tiny-imperative-programming-language><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Mostly explains the example language's grammar.</p><p><strong>Exercise 2.2:</strong>
Exercise 2.3: Show how the following statement can be normalized:
<code>x = (**f)(g()+h())</code></p><pre tabindex=0><code>t1 = *f;
t2 = *t1;
t3 = g();
t4 = h();
t5 = t3 + t4;
x = t2(t3);
</code></pre><p><strong>End of Exercise 2.2:</strong></p><h2 id=25-control-flow-graphs>2.5 Control Flow Graphs
<a class=header-link href=#25-control-flow-graphs><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><blockquote><p>A control flow graph (CFG) is a directed graph, in which nodes correspond to
statements and edges represent possible flow of control.</p></blockquote><blockquote><p>has a single point of entry and single point of exit</p></blockquote><blockquote><p>pred(v): set of predecessor nodes
succ(v): set of successor nodes</p></blockquote><blockquote><p>For programs that are fully normalized each node corresponds to only one
operation.</p></blockquote><h1 id=chapter-3-type-analysis>Chapter 3: Type Analysis
<a class=header-link href=#chapter-3-type-analysis><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Certain operations should only work on certain types. E.g., <code>*</code> can only be
called for pointers and <code>null</code>.</p><p>We cannot guarantee that no types error appear in runtime. So we use an
approximation:</p><blockquote><p>typability. A program is typable if it satisfies a collection of type
constraints that is systematically derived, typically from the program AST</p></blockquote><p>In other words we will check for types and as a result any program which passes
our checks will not violate the type requirements.</p><blockquote><p>the above requirements are guaranteed to hold during execution, but the
converse is not true. Thus, our type analysis will be conservative and reject
some programs that in fact will not violate any requirements during execution.</p></blockquote><p>This will reject some programs that might not adhere to these type requirements
but also do not result in runtime errors, but that is OK.</p><blockquote><p>For a given program we generate a constraint system and define the program to
be typable when the constraints are solvable.</p></blockquote><blockquote><p>A solution assigns a type to each type variable, such that all equality constraints are satisfied.</p></blockquote><p>We create the type constraints for a program and then create a solution that
satisfies the constraint. The solution is basically assigning a type to each
variable.</p><blockquote><p>The correctness claim for the type analysis is that the existence of a
solution implies that the specified runtime errors cannot occur during
execution</p></blockquote><p>But how do we create solutions? Unification</p><blockquote><p>If solutions exist, then they can be computed in almost linear time using a
unification algorithm for regular terms</p></blockquote><p>Our type analysis has limitations.</p><ol><li>It's <code>flow-insensitive</code>. For example, it rejects programs where a variable is
declared as a pointer and is used as an int later while the type changes
during execution.</li><li><blockquote><p>Another limitation, which is even more significant from a practical point
of view, is the current treatment of polymorphic types</p></blockquote></li><li><blockquote><p>it ignores many other kinds of runtime errors, such as dereference of null
pointers, reading of uninitialized variables, division by zero, and the
more subtle escaping stack cell</p></blockquote></li></ol><h1 id=chapter-4-lattice-theory>Chapter 4: Lattice Theory
<a class=header-link href=#chapter-4-lattice-theory><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1></div><footer><p class=meta></span></p></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#preface>Preface</a></li><li><a href=#chapter-1-introduction>Chapter 1: Introduction</a></li><li><a href=#chapter-2-a-tiny-imperative-programming-language>Chapter 2: A Tiny Imperative Programming Language</a><ul><li><a href=#25-control-flow-graphs>2.5 Control Flow Graphs</a></li></ul></li><li><a href=#chapter-3-type-analysis>Chapter 3: Type Analysis</a></li><li><a href=#chapter-4-lattice-theory>Chapter 4: Lattice Theory</a></li></ul></nav></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2024 Parsia-Clone - <a href=https://parsiya.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>