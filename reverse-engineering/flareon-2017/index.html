<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>FlareOn 2017 CTF Notes</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=http://parsiya.io/clone.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=http://parsiya.io/favicon.png rel=icon><meta name=description content><meta name=keywords content="[Parsia Hakimian Parsiya infosec information security]"><meta name=author content="Parsia-Clone"><meta name=generator content="Hugo 0.80.0"><meta name=twitter:card content="summary"><meta name=twitter:title content="FlareOn 2017 CTF Notes"><meta name=twitter:description content="Random notes from FlareOn-2017 Challenge 1 - login.html Look inside login.html. It&rsquo;s ROT-13.
 2 - IgniteMe.exe Simple x86 binary, looks like a bunch of XOR-es done on byte_403000.
Write the prompt and call sub_4010F0 (it&rsquo;s not waiting for input yet).
F7: Step Into F8: Step Over
var1 = 0 var8 = 0 if (var8 < 0x104) // 0x104 = 260 { ecx = var8 ecx+Buffer = 0 // is it zero-ing out a 260 byte buffer?"><meta name=twitter:domain content="parsiya.io"><meta name=twitter:creator content="@CryptoGangsta"></head><body><header role=banner><hgroup><h1><a href=http://parsiya.io/>Parsia-Clone</a></h1><h2>'Documentation is a love letter that you write to your future self.' - Damian Conway</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value;">
<option value>Navigate…</option>
<option value=https://github.com/parsiya/Parsia-Clone>» Parsia-Clone on Github</option>
<option value=https://parsiya.net/categories/clone/>» How did I make this?</option>
<option value=https://parsiya.net>» My Main Website</option></select></fieldset><ul class=main-navigation><li><a href=https://github.com/parsiya/Parsia-Clone title="Parsia-Clone on Github" target=_blank>Parsia-Clone on Github</a></li><li><a href=https://parsiya.net/categories/clone/ title="How did I make this?" target=_blank>How did I make this?</a></li><li><a href=https://parsiya.net title="My Main Website" target=_blank>My Main Website</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:http://parsiya.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>40 minute read
- <a class=label href=http://parsiya.io/categories/reverse-engineering/>Reverse engineering</a></p><h1 class=entry-title>FlareOn 2017 CTF Notes</h1><a href=https://github.com/parsiya/Parsia-Clone/tree/main/reverse-engineering/flareon-2017/index.md target=_blank>Github Link</a></header><div class=entry-content><h1 id=random-notes-from-flareon-2017-challenge>Random notes from FlareOn-2017 Challenge</h1><h1 id=1---loginhtml>1 - login.html</h1><p>Look inside <code>login.html</code>. It&rsquo;s ROT-13.</p><hr><h1 id=2---ignitemeexe>2 - IgniteMe.exe</h1><p>Simple x86 binary, looks like a bunch of XOR-es done on <code>byte_403000</code>.</p><p>Write the prompt and call <code>sub_4010F0</code> (it&rsquo;s not waiting for input yet).</p><p>F7: Step Into
F8: Step Over</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>var1 <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>
var8 <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>

<span style=color:#719e07>if</span> (var8 <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0x104</span>) <span style=color:#586e75>// 0x104 = 260
</span><span style=color:#586e75></span>{
  ecx <span style=color:#719e07>=</span> var8
  ecx<span style=color:#719e07>+</span>Buffer <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span> <span style=color:#586e75>// is it zero-ing out a 260 byte buffer?
</span><span style=color:#586e75></span>
  <span style=color:#586e75>// eax = var8
</span><span style=color:#586e75></span>  <span style=color:#586e75>// eax++
</span><span style=color:#586e75></span>  <span style=color:#586e75>// var8 = eax
</span><span style=color:#586e75></span>
  var8<span style=color:#719e07>++</span>
}

<span style=color:#719e07>*</span>edx <span style=color:#719e07>=</span> NumberOfBytesRead <span style=color:#719e07>=</span> <span style=color:#2aa198>0x98</span> <span style=color:#719e07>=</span> <span style=color:#2aa198>152</span>  <span style=color:#586e75>// why is this not 0?
</span><span style=color:#586e75></span>push <span style=color:#719e07>*</span>dex
push <span style=color:#2aa198>0x104</span> <span style=color:#719e07>=</span> <span style=color:#2aa198>206</span> <span style=color:#586e75>// nNumberOfBytesToRead
</span><span style=color:#586e75></span>push Buffer (<span style=color:#2aa198>260</span> <span style=color:#dc322f>char</span> zero<span style=color:#719e07>-</span>ed out that we saw before)

ds:ReadFile <span style=color:#719e07>=</span> read from input and put into Buffer.

counter <span style=color:#719e07>=</span> var8 <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span> <span style=color:#586e75>// var8 is reset
</span><span style=color:#586e75></span>
<span style=color:#719e07>while</span> (counter <span style=color:#719e07>&lt;</span> strlen(Buffer))
{
  eax <span style=color:#719e07>=</span> Buffer

  push eax <span style=color:#586e75>// push Buffer
</span><span style=color:#586e75></span>
  strlen(Buffer) <span style=color:#586e75>// sub_401020(Buffer) see below
</span><span style=color:#586e75></span>
  <span style=color:#719e07>if</span> (strlen(Buffer) <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) <span style=color:#586e75>// function returns 0 if string is empty
</span><span style=color:#586e75></span>  {
    <span style=color:#586e75>// mov eax, 1
</span><span style=color:#586e75></span>    <span style=color:#586e75>// return
</span><span style=color:#586e75></span>    <span style=color:#719e07>return</span> <span style=color:#2aa198>1</span>
  }
  <span style=color:#719e07>else</span>
  {
      <span style=color:#586e75>// dl = Buffer[ecx]
</span><span style=color:#586e75></span>      <span style=color:#586e75>// var1 = dl
</span><span style=color:#586e75></span>      <span style=color:#586e75>// var1 = Buffer[ecx]
</span><span style=color:#586e75></span>      
      <span style=color:#586e75>// look for 0x0A
</span><span style=color:#586e75></span>      <span style=color:#586e75>// mov var1, eax
</span><span style=color:#586e75></span>      <span style=color:#586e75>// cmp eax, 0x0A
</span><span style=color:#586e75></span>
      <span style=color:#586e75>// look for 0x0D
</span><span style=color:#586e75></span>      <span style=color:#586e75>// movzx  ecx, [ebp+var_1]
</span><span style=color:#586e75></span>      <span style=color:#586e75>// cmp     ecx, 0Dh
</span><span style=color:#586e75></span>      <span style=color:#586e75>// jz      short loc_4011A4
</span><span style=color:#586e75></span>
      <span style=color:#586e75>// check for 0x00
</span><span style=color:#586e75></span>      <span style=color:#586e75>// movzx   edx, [ebp+var_1]
</span><span style=color:#586e75></span>      <span style=color:#586e75>// test    edx, edx
</span><span style=color:#586e75></span>      <span style=color:#586e75>// jz      short loc_4011A4
</span><span style=color:#586e75></span>      
      <span style=color:#719e07>if</span> (Buffer[counter] <span style=color:#719e07>!=</span> <span style=color:#2aa198>0x0A</span> <span style=color:#719e07>||</span> <span style=color:#2aa198>0x0D</span> <span style=color:#719e07>||</span> <span style=color:#2aa198>0x00</span> ) <span style=color:#586e75>// newline or end of string
</span><span style=color:#586e75></span>      {
        <span style=color:#586e75>// eax = var8 // ecx
</span><span style=color:#586e75></span>        <span style=color:#586e75>// cl = Buffer[ecx]
</span><span style=color:#586e75></span>        <span style=color:#586e75>// byte_403078[eax] = cl // Copy buffer to byte_403078 but bypass new those 3 chars
</span><span style=color:#586e75></span>        byte_403078[counter] <span style=color:#719e07>=</span> Buffer[counter]
      }

      loc_4011A4:
      <span style=color:#586e75>// edx = var8
</span><span style=color:#586e75></span>      <span style=color:#586e75>// edx++
</span><span style=color:#586e75></span>      <span style=color:#586e75>// var8 = edx
</span><span style=color:#586e75></span>      counter<span style=color:#719e07>++</span>
    }
}
</code></pre></div><p><strong>Seems like it reads input and removes newlines and copies the rest to byte_403078.</strong></p><p><code>sub_401020</code></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>arg0 <span style=color:#719e07>=</span> Buffer
var4 <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>

loc_40102B:

eax <span style=color:#719e07>=</span> Buffer
eax <span style=color:#719e07>=</span> eax <span style=color:#719e07>+</span> var4 <span style=color:#586e75>// 0
</span><span style=color:#586e75></span>
<span style=color:#586e75>// movsx ecx, byte ptr [eax]
</span><span style=color:#586e75></span>ecx <span style=color:#719e07>=</span> Buffer[<span style=color:#2aa198>0</span>]

<span style=color:#586e75>// test ecx, ecx
</span><span style=color:#586e75>// jz short loc_401043
</span><span style=color:#586e75></span>
<span style=color:#719e07>if</span> (ecx <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) <span style=color:#719e07>goto</span> loc_401043 <span style=color:#586e75>// e.g. jmp there if we have reached the end of the string
</span><span style=color:#586e75></span>
<span style=color:#586e75>// else
</span><span style=color:#586e75></span>
<span style=color:#586e75>// edx = var4
</span><span style=color:#586e75>// edx++
</span><span style=color:#586e75>// var4 = edx
</span><span style=color:#586e75></span>
var4<span style=color:#719e07>++</span>

<span style=color:#719e07>goto</span> loc_40102B

loc_401043:

<span style=color:#586e75>// eax = var4
</span><span style=color:#586e75>// return
</span><span style=color:#586e75></span>
<span style=color:#719e07>return</span> var4
</code></pre></div><p>In other words it&rsquo;s just strlen(Buffer).</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>var4 <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>

<span style=color:#719e07>while</span> (Buffer[var4] <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>)
{
  var4<span style=color:#719e07>++</span>
}

<span style=color:#719e07>return</span> var4
</code></pre></div><p>Now let&rsquo;s look at <code>sub_401050</code></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>push byte_403078  <span style=color:#586e75>// cleaned string
</span><span style=color:#586e75></span>varC <span style=color:#719e07>=</span> strlen(byte_403078)  <span style=color:#586e75>// strlen(cleaned_string)
</span><span style=color:#586e75></span>
call sub_401000
eax <span style=color:#719e07>=</span> <span style=color:#2aa198>0x00700004</span>
var1 <span style=color:#719e07>=</span> al <span style=color:#719e07>=</span> <span style=color:#2aa198>0x04</span>

eax <span style=color:#719e07>=</span> varC <span style=color:#586e75>// len(cleaned string)
</span><span style=color:#586e75></span>eax<span style=color:#719e07>--</span>
var8 <span style=color:#719e07>=</span> eax <span style=color:#586e75>// varC--
</span><span style=color:#586e75></span>
<span style=color:#719e07>if</span> (var8 <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) <span style=color:#586e75>// if (len(cleaned_string) - 1 &lt; 0) aka if (len(cleaned_string) == 0)
</span><span style=color:#586e75></span>{
  var8 <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>
  <span style=color:#719e07>if</span> (var8 <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0x27</span>) <span style=color:#586e75>// which obviously always happens
</span><span style=color:#586e75></span>  {
    <span style=color:#586e75>// eax = var8
</span><span style=color:#586e75></span>    <span style=color:#586e75>// ecx = xor_string[eax]
</span><span style=color:#586e75></span>    <span style=color:#586e75>// edx = var8
</span><span style=color:#586e75></span>    <span style=color:#586e75>// eax = target_string[var8]
</span><span style=color:#586e75></span>    <span style=color:#586e75>// cmp ecx, eax
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (xor_string[var8] <span style=color:#719e07>==</span> target_string[var8])
    {
      var8<span style=color:#719e07>++</span>
    }
    <span style=color:#719e07>else</span>
    {
      <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>
    }
  }
}
<span style=color:#719e07>else</span>
{
  edx <span style=color:#719e07>=</span> var8
  eax <span style=color:#719e07>=</span> cleaned_string[var8] <span style=color:#586e75>// in this case it&#39;s the last char (because null termination?)
</span><span style=color:#586e75></span>  ecx <span style=color:#719e07>=</span> var1 <span style=color:#586e75>// 0x04
</span><span style=color:#586e75></span>  eax <span style=color:#719e07>=</span> eax xor ecx <span style=color:#586e75>// last one is xor-ed by 0x04
</span><span style=color:#586e75></span>  edx <span style=color:#719e07>=</span> var8
  mov byte_403180[edx], al <span style=color:#586e75>// first char of xor_string = last char of cleaned_string xor 0x04
</span><span style=color:#586e75></span>  var1 <span style=color:#719e07>=</span> cl <span style=color:#586e75>// clearned_string[var8]
</span><span style=color:#586e75></span>
  var8<span style=color:#719e07>--</span>

  <span style=color:#586e75>// next round the previous char is xor-ed with next one
</span><span style=color:#586e75></span>
  <span style=color:#586e75>// in other words
</span><span style=color:#586e75></span>  <span style=color:#586e75>// parse the string in reverse
</span><span style=color:#586e75></span>  <span style=color:#586e75>// first char is xor-ed by 0x04
</span><span style=color:#586e75></span>  <span style=color:#586e75>// next chat is xor-ed by previous char in clearned_string
</span><span style=color:#586e75></span>}
</code></pre></div><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>kstr1 <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;0D2649452A1778442B6C5D5E45122F172B446F6E56095F454773260A0D1317484201404D0C0269&#34;</span>

str1 <span style=color:#719e07>=</span> str1<span style=color:#719e07>.</span>decode(<span style=color:#2aa198>&#34;hex&#34;</span>)

result <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;&#34;</span>

<span style=color:#586e75># key = unhexlify(&#34;04&#34;)</span>
key <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;04&#34;</span><span style=color:#719e07>.</span>decode(<span style=color:#2aa198>&#34;hex&#34;</span>)

<span style=color:#719e07>def</span> <span style=color:#268bd2>xor2</span>(plaintext, key):
    <span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;&#34;</span><span style=color:#719e07>.</span>join(<span style=color:#b58900>chr</span>(<span style=color:#b58900>ord</span>(x) <span style=color:#719e07>^</span> <span style=color:#b58900>ord</span>(y)) <span style=color:#719e07>for</span> x, y <span style=color:#719e07>in</span> <span style=color:#b58900>zip</span>(plaintext, key))

<span style=color:#719e07>for</span> char <span style=color:#719e07>in</span> str1[::<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]:
    key <span style=color:#719e07>=</span> xor2(key, char)
    result <span style=color:#719e07>+=</span> key
    <span style=color:#719e07>print</span> key<span style=color:#719e07>.</span>encode(<span style=color:#2aa198>&#39;hex&#39;</span>)

<span style=color:#719e07>print</span> result[::<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]

</code></pre></div><p><code>sub_401000</code></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>eax <span style=color:#719e07>=</span> <span style=color:#2aa198>0x80070057</span>
edx <span style=color:#719e07>=</span> eax <span style=color:#719e07>=</span> <span style=color:#2aa198>0x80070057</span>
xor ax, ax  <span style=color:#586e75>// eax = 0x80070000 -- the first 4 bytes of eax (ax) is zero-ed
</span><span style=color:#586e75></span>rol eax, <span style=color:#2aa198>4</span>  <span style=color:#586e75>// eax = 0x00700008 -- remember it&#39;s rotate left by 4 bits (not bytes)
</span><span style=color:#586e75></span>shr ax, <span style=color:#2aa198>1</span>   <span style=color:#586e75>// eax = 0x00700004 -- remember shift-right by 1 bit on only ax (everything is replaced by 0 last one goes into CF but the rest fall off)
</span><span style=color:#586e75></span>
<span style=color:#719e07>return</span> eax <span style=color:#2aa198>0x00700004</span>
</code></pre></div><p><strong>flag: <a href=mailto:R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com>R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com</a></strong></p><hr><h1 id=3---greek_to_meexe>3 - greek_to_me.exe</h1><p>Running strings (from Sysinternals) on it we get:</p><ul><li><code>-nobanner</code>: do not display banner.</li><li><code>-o</code>: print the offset of the string (useful in case we want to use find the string in a hex editor like HxD).</li></ul><pre><code>PS &gt; .\SysinternalsSuite\strings64.exe -o -nobanner .\3-GreektoMe\greek_to_me.exe
0077:!This program cannot be run in DOS mode.
0176:Rich
0432:.text
0472:.rdata
0526:SVW
0617:h0 @
0755:s|j
0759:j+hH @
0786:( @
0794:_^[
0824:$ @
0839:VWj
0851:  @
0860:tzht @
0911:t@h
0928:t/j
0986:( @
1015:tQS
1021:VWj
1095:_^[
1584:Nope, that's not it.
1608:Congratulations! But wait, where's my flag?
1652:127.0.0.1
1752:WS2_32.dll
</code></pre><p><code>WS2_32.dll</code> is the Windows socket library. So network connectivity.</p><p>Here&rsquo;s some interesting info that I found when searching for it: <a href=https://nakedsecurity.sophos.com/2009/10/12/windows-ws232dll-file-safe/>https://nakedsecurity.sophos.com/2009/10/12/windows-ws232dll-file-safe/</a></p><p>Looking at <code>127.0.0.1</code> this means the application has network connectivity.</p><p>Initially I thought the application is trying to contact a local server. So I ran procmon and Wireshark (that can capture local loopback on Windows using <code>npcap</code> see <a href=https://wiki.wireshark.org/CaptureSetup/Loopback>https://wiki.wireshark.org/CaptureSetup/Loopback</a>) and ran the application. I saw no <code>TCP/UDP Connect</code> events procmon or any local loopback traffic in Wireshark.</p><p>The app starts and then does nothing. If we run <code>netstat -anb</code> in an Admin command prompt, we can see the app is listening on port <code>2222</code>.</p><pre><code> TCP    127.0.0.1:2222         0.0.0.0:0              LISTENING       5816
[greek_to_me.exe]
</code></pre><p>Or for example using <code>TCPView</code> for Sysinternals.</p><p>Supposedly we have to send a string of stuff to this socket.</p><h2 id=ida>IDA</h2><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>public</span> <span style=color:#268bd2>start</span>
<span style=color:#268bd2>start</span> <span style=color:#268bd2>proc</span> <span style=color:#268bd2>near</span>
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_401008</span>
<span style=color:#268bd2>xor</span>     <span style=color:#b58900>eax</span>, <span style=color:#b58900>eax</span>
<span style=color:#268bd2>retn</span>
<span style=color:#268bd2>start</span> <span style=color:#268bd2>endp</span>
</code></pre></div><p><code>sub_401008</code> is called, then app returns 0 and exits.</p><p>Inside <code>sub_401008</code> we see another subroutine <code>sub_401121</code>. Before that a <code>*buf</code> is pushed (as an argument) and is empty.</p><h3 id=sub_401121>sub_401121</h3><p>We can see the socket being constructed.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>lea</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>WSAData</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>eax</span>             <span style=color:#586e75>; lpWSAData</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>202h</span>            <span style=color:#586e75>; wVersionRequested</span>
<span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>WSAStartup</span>
<span style=color:#268bd2>test</span>    <span style=color:#b58900>eax</span>, <span style=color:#b58900>eax</span>
<span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_401147</span>
</code></pre></div><p>Then if <code>WSAStartup</code> was successful we can see the port and other parameters being passed to <code>socket</code>. IDA highlights a lot of them of us.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_401147:
<span style=color:#268bd2>push</span>    <span style=color:#b58900>esi</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edi</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>6</span>               <span style=color:#586e75>; protocol</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>1</span>               <span style=color:#586e75>; type</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>2</span>
<span style=color:#268bd2>pop</span>     <span style=color:#b58900>edi</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edi</span>             <span style=color:#586e75>; af</span>
<span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>socket</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>esi</span>, <span style=color:#b58900>eax</span>
<span style=color:#268bd2>cmp</span>     <span style=color:#b58900>esi</span>, <span style=color:#2aa198>0FFFFFFFFh</span>
<span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_4011D8</span>
</code></pre></div><p>We can see <code>socket</code> here. And of course the arguments are pushed to the stack from right to left.</p><ul><li>af = 2 = AF_INET = IPv4</li><li>type = 1 = SOCK_STREAM = TCP socket</li><li>protocol = 6 = IPPROTO_TCP = TCP</li></ul><p>The address to bind to.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>push</span>    <span style=color:#268bd2>offset</span> <span style=color:#268bd2>cp</span>       <span style=color:#586e75>; &#34;127.0.0.1&#34;</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>name.sa_family</span>], <span style=color:#b58900>di</span>
<span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>inet_addr</span>
</code></pre></div><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms738563(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms738563(v=vs.85).aspx</a></p><p>The string &ldquo;127.0.0.1&rdquo; is being converted to an inet address.</p><p>Then port</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>push</span>    <span style=color:#2aa198>8AEh</span>            <span style=color:#586e75>; hostshort</span>
<span style=color:#268bd2>mov</span>     <span style=color:#dc322f>dword</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>name.sa_data</span><span style=color:#719e07>+</span><span style=color:#2aa198>2</span>], <span style=color:#b58900>eax</span>
<span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>htons</span>
</code></pre></div><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms738557(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms738557(v=vs.85).aspx</a></p><p>&ldquo;The htons function converts a u_short from host to TCP/IP network byte order (which is big-endian).&rdquo;</p><p><code>0x8AE</code> is <code>2222</code> decimal.</p><p>Then bind</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#dc322f>word</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>name.sa_data</span>], <span style=color:#b58900>ax</span>
<span style=color:#268bd2>lea</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>name</span>]
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>10h</span>             <span style=color:#586e75>; namelen</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>eax</span>             <span style=color:#586e75>; name</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>esi</span>             <span style=color:#586e75>; s</span>
<span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>bind</span>
</code></pre></div><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms737550(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms737550(v=vs.85).aspx</a></p><p>&ldquo;The bind function associates a local address with a socket.&rdquo;</p><p>After there is <code>listen</code>, <code>accept</code> and <code>recv</code> but we already know what they do.</p><p>Finally we are listening on <code>127.0.0.1:2222</code>.</p><p>Let&rsquo;s take a closer look at <code>recv</code>.</p><p>&ldquo;The recv function receives data from a connected socket or a bound connectionless socket.&rdquo;</p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740121(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms740121(v=vs.85).aspx</a></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>               <span style=color:#586e75>; flags</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>4</span>               <span style=color:#586e75>; len</span>
<span style=color:#268bd2>push</span>    [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>buf</span>]       <span style=color:#586e75>; buf</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edi</span>             <span style=color:#586e75>; s</span>
<span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>recv</span>
<span style=color:#268bd2>test</span>    <span style=color:#b58900>eax</span>, <span style=color:#b58900>eax</span>
<span style=color:#268bd2>jle</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_4011CA</span>
</code></pre></div><p><code>Buf</code> from the parameter is going to be the pointer to the data received. <code>recv</code> returns the number of bytes received (which going to be in eax).</p><p>If nothing was received, the <code>jle</code> is successful and socket is closed.</p><p>Otherwise the function returns the number of received bytes.</p><p><strong>tl;dr</strong></p><p><code>int bindAndListen(*buf)</code> listens on <code>127.0.0.1:2222</code>, data is in buf and returns the number of bytes received.</p><p>Seems like it receives (or processed data in 4 byte chunks) because ecx after leaving the function is pointing to only the first 4 bytes (and eax after recv was 4).</p><p>Now these parts are interesting.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_401029:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, <span style=color:#268bd2>offset</span> <span style=color:#268bd2>loc_40107C</span>
<span style=color:#268bd2>add</span>     <span style=color:#b58900>ecx</span>, <span style=color:#2aa198>79h</span>
</code></pre></div><p>ecx after this is pointing to this place:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>.text:004010<span style=color:#268bd2>F5</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>                               <span style=color:#586e75>; flags</span>
.text:004010<span style=color:#268bd2>F7</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>2Bh</span>                             <span style=color:#586e75>; len</span>
.text:004010<span style=color:#268bd2>F9</span> <span style=color:#268bd2>push</span>    <span style=color:#268bd2>offset</span> <span style=color:#268bd2>aCongratulation</span>          <span style=color:#586e75>; &#34;Congratulations! But wait, where&#39;s my flag?&#34;</span>
.text:004010<span style=color:#268bd2>FE</span> <span style=color:#268bd2>push</span>    [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>s</span>]                         <span style=color:#586e75>; s</span>
.text:00401101 <span style=color:#268bd2>call</span>    <span style=color:#b58900>ds</span>:<span style=color:#268bd2>send</span>
</code></pre></div><p>Then this one is misleading. Seems like this is data but IDA thinks it&rsquo;s code. Let&rsquo;s play along for now.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, <span style=color:#268bd2>offset</span> <span style=color:#268bd2>loc_40107C</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>dl</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>buf</span>]
</code></pre></div><p>Now dl points to the first byte that we sent to the socket.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_401039:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>bl</span>, [<span style=color:#b58900>eax</span>]         <span style=color:#586e75>; bl = 0x33 (first byte there)</span>
<span style=color:#268bd2>xor</span>     <span style=color:#b58900>bl</span>, <span style=color:#b58900>dl</span>            <span style=color:#586e75>; bl = 0x33 xor our_first_byte</span>
<span style=color:#268bd2>add</span>     <span style=color:#b58900>bl</span>, <span style=color:#2aa198>22h</span>           <span style=color:#586e75>; bl += 0x22</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>eax</span>], <span style=color:#b58900>bl</span>         <span style=color:#586e75>; *eax = bl</span>
<span style=color:#268bd2>inc</span>     <span style=color:#b58900>eax</span>               <span style=color:#586e75>; eax++ (next char?)</span>
<span style=color:#268bd2>cmp</span>     <span style=color:#b58900>eax</span>, <span style=color:#b58900>ecx</span>          <span style=color:#586e75>; ecx is the address of the second section</span>
<span style=color:#268bd2>jl</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_401039</span>  <span style=color:#586e75>; check if we have reached the next section</span>
</code></pre></div><p>Seems like all that section is being XOR-ed with just the first byte that we sent (in this case 0x30).</p><p>To see data that is being XOR-ed (blob1), we can either grab it here or from a hex editor by opening the binary.</p><p>33 E1 C4 99 11 06 81 16 F0 32 9F C4 91 17 06 81 14 F0 06 81 15 F1 C4 91 1A 06 81 1B E2 06 81 18 F2 06 81 19 F1 06 81 1E F0 C4 99 1F C4 91 1C 06 81 1D E6 06 81 62 EF 06 81 63 F2 06 81 60 E3 C4 99 61 06 81 66 BC 06 81 67 E6 06 81 64 E8 06 81 65 9D 06 81 6A F2 C4 99 6B 06 81 68 A9 06 81 69 EF 06 81 6E EE 06 81 6F AE 06 81 6C E3 06 81 6D EF 06 81 72 E9 06 81 73 7C</p><p>blob2 = (blob xor first_byte) + 0x22</p><p>CyberChef recipe for this (assuming our first byte is 0x30) is (remember you have to have one space after the last hex byte in input):</p><pre><code>From_Hexdump()
XOR({'option':'Hex','string':'30'},'Standard',false)
ADD({'option':'Hex','string':'22'})
To_Hex('Space')
To_Upper_case('All')
</code></pre><p>blob2 (with first byte 0x30)</p><pre><code>25 F3 16 CB 43 58 D3 48 E2 24 D1 16 C3 49 58 D3 46 E2 58 D3 47 E3 16 C3 4C 58 D3 4D F4 58 D3 4A E4 58 D3 4B E3 58 D3 50 E2 16 CB 51 16 C3 4E 58 D3 4F F8 58 D3 74 01 58 D3 75 E4 58 D3 72 F5 16 CB 73 58 D3 78 AE 58 D3 79 F8 58 D3 76 FA 58 D3 77 CF 58 D3 7C E4 16 CB 7D 58 D3 7A BB 58 D3 7B 01 58 D3 80 00 58 D3 81 C0 58 D3 7E F5 58 D3 7F 01 58 D3 64 FB 58 D3 65 6E
</code></pre><p>Then a new function is called.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#2aa198>4198524</span>]
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>], <span style=color:#b58900>eax</span>  <span style=color:#586e75>; varC points to blob2 now</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>79h</span>
<span style=color:#268bd2>push</span>    [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>]
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_4011E6</span>  <span style=color:#586e75>; sub_4011E6(blob2, 0x79)</span>
<span style=color:#268bd2>pop</span>     <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>pop</span>     <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>movzx</span>   <span style=color:#b58900>eax</span>, <span style=color:#b58900>ax</span>
<span style=color:#268bd2>cmp</span>     <span style=color:#b58900>eax</span>, <span style=color:#2aa198>0FB5Eh</span>
<span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_40107C</span>
</code></pre></div><h3 id=sub_4011e6>sub_4011E6</h3><p>arg4 = blob2_len = 0x79 = 121 = length of blob1 and blob2
arg0 = blob2</p><p>initial part before loops</p><p>blob2 in blocks of 20</p><pre><code>25 F3 16 CB 43 58 D3 48 E2 24 D1 16 C3 49 58 D3 46 E2 58 D3 
47 E3 16 C3 4C 58 D3 4D F4 58 D3 4A E4 58 D3 4B E3 58 D3 50 
E2 16 CB 51 16 C3 4E 58 D3 4F F8 58 D3 74 01 58 D3 75 E4 58 
D3 72 F5 16 CB 73 58 D3 78 AE 58 D3 79 F8 58 D3 76 FA 58 D3 
77 CF 58 D3 7C E4 16 CB 7D 58 D3 7A BB 58 D3 7B 01 58 D3 80 
00 58 D3 81 C0 58 D3 7E F5 58 D3 7F 01 58 D3 64 FB 58 D3 65 
6E
</code></pre><p>If we go by blocks of 20, one last byte will remain.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>edx</span>  = <span style=color:#2aa198>0x79</span> = <span style=color:#b58900>si</span><span style=color:#268bd2>ze</span> <span style=color:#268bd2>of</span> <span style=color:#b58900>bl</span><span style=color:#268bd2>ob2</span>
<span style=color:#268bd2>ecx</span>  = <span style=color:#2aa198>0xFF</span>
<span style=color:#268bd2>var4</span> = <span style=color:#2aa198>0xFF</span>
<span style=color:#268bd2>eax</span>  = <span style=color:#2aa198>0x14</span> = <span style=color:#2aa198>20</span> <span style=color:#268bd2>decimal</span> = <span style=color:#b58900>bl</span><span style=color:#268bd2>ock</span> <span style=color:#b58900>si</span><span style=color:#268bd2>ze</span>
</code></pre></div><p>init done</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>di <span style=color:#719e07>=</span> var4

esi <span style=color:#719e07>=</span> edx

<span style=color:#719e07>if</span> (edx <span style=color:#719e07>&gt;</span> eax) <span style=color:#586e75>// if remaining data &gt; block size use blocksize, otherwise use remaining data in blob2
</span><span style=color:#586e75></span>{
  esi <span style=color:#719e07>=</span> eax  <span style=color:#586e75>// cmova esi, eax
</span><span style=color:#586e75></span>}

edx <span style=color:#719e07>=</span> edx <span style=color:#719e07>-</span> esi <span style=color:#586e75>// remove one block from size of remaining data
</span><span style=color:#586e75></span>

<span style=color:#586e75>// initial values
</span><span style=color:#586e75></span>var4 <span style=color:#719e07>=</span> <span style=color:#2aa198>0xFF</span>
ecx  <span style=color:#719e07>=</span> <span style=color:#2aa198>0xFF</span>

<span style=color:#586e75>// for each block do these
</span><span style=color:#586e75></span>di <span style=color:#719e07>=</span> var4

<span style=color:#719e07>for</span> (i<span style=color:#719e07>=</span><span style=color:#2aa198>0</span>; i<span style=color:#719e07>&lt;</span>esi; i<span style=color:#719e07>++</span>)
{
  di <span style=color:#719e07>=</span> di <span style=color:#719e07>+</span> blob2[i]
  var4 <span style=color:#719e07>=</span> di
  ecx <span style=color:#719e07>=</span> ecx <span style=color:#719e07>+</span> di
}

ax <span style=color:#719e07>=</span> first byte of var4
shr di, <span style=color:#2aa198>8</span> <span style=color:#586e75>// shift right one byte. In case of di, second byte is zero-ed and replaces first byte (e.g. 0B 25 &gt;  00 0B)
</span><span style=color:#586e75></span>          <span style=color:#586e75>// in other worde divide di by 256
</span><span style=color:#586e75></span>ax <span style=color:#719e07>=</span> ax <span style=color:#719e07>+</span> di
eax <span style=color:#719e07>=</span> ax <span style=color:#586e75>// doesn&#39;t matter
</span><span style=color:#586e75></span>var4 <span style=color:#719e07>=</span> eax <span style=color:#586e75>// this overwrites all of var4 (remember we only copied the first byte)
</span><span style=color:#586e75></span>eax <span style=color:#719e07>=</span> cl (only first byte of ecx from last <span style=color:#719e07>while</span> is saved)
shr cx, <span style=color:#2aa198>8</span> (shift cx right one byte) <span style=color:#586e75>// cx = cx / 8
</span><span style=color:#586e75></span>ax <span style=color:#719e07>=</span> ax <span style=color:#719e07>+</span> cx
ecx <span style=color:#719e07>=</span> ax
eax <span style=color:#719e07>=</span> <span style=color:#2aa198>0x14</span>  <span style=color:#586e75>// reset block size
</span><span style=color:#586e75></span>
</code></pre></div><p>After all these</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_40124A:
<span style=color:#268bd2>movzx</span>   <span style=color:#b58900>edx</span>, <span style=color:#dc322f>byte</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>shl</span>     <span style=color:#b58900>ecx</span>, <span style=color:#2aa198>8</span>
<span style=color:#268bd2>and</span>     <span style=color:#b58900>eax</span>, <span style=color:#2aa198>0FF00h</span>
<span style=color:#268bd2>add</span>     <span style=color:#b58900>eax</span>, <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>cx</span>, <span style=color:#dc322f>word</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4</span>]
<span style=color:#268bd2>shr</span>     <span style=color:#b58900>cx</span>, <span style=color:#2aa198>8</span>
<span style=color:#268bd2>add</span>     <span style=color:#b58900>dx</span>, <span style=color:#b58900>cx</span>
<span style=color:#268bd2>or</span>      <span style=color:#b58900>ax</span>, <span style=color:#b58900>dx</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>esp</span>, <span style=color:#b58900>ebp</span>
<span style=color:#268bd2>pop</span>     <span style=color:#b58900>ebp</span>
<span style=color:#268bd2>retn</span>
</code></pre></div><p>Seems like it does not matter, the function returns eax which only first 2 bytes are populated.</p><p>Which means in the end we will only have 65535 different combinations.</p><hr><h3 id=after-sub_4011e6>After sub_4011E6</h3><p>0x00 = 2597</p><p>0x79 = 21D3</p><p>What we want is, blob2 to be valid x86 instructions.</p><p>So we want to bruteforce all the XORs</p><p>Works for <code>A2</code>.</p><p>See <code>fuzz5.py</code> for WinAppDbg in-memory brute force.</p><p>We could have just created a Python program.</p><ol><li>Run the application.</li><li>Send a byte.</li><li>Print the response.</li><li>Go to 1.</li></ol><p>But I learned WinAppDbg, well kinda sorta.</p><p><strong>flag: <a href=mailto:et_tu_brute_force@flare-on.com>et_tu_brute_force@flare-on.com</a></strong></p><hr><h1 id=4---notepadexe>4 - Notepad.exe</h1><p>Seems like we need a Windows 7 VM for this. I read that it crashed on Windows 10. That meant I had to setup a Windows 7 VM.</p><p>Dropping it in PEStudio gives us a bunch of information.</p><p>In Resource Hacker we see some dialog named &ldquo;NPENCODINGDIALOG&rdquo;. I don&rsquo;t think I have ever seen it in real notepad. But I could be wrong. This is from the save dialog. You can set the encoding of the file. I am not sure why it&rsquo;s in a different location, could be normal.</p><p>Running it in procmon did not show anything special.</p><h2 id=in-ida>In IDA</h2><p>We can see a bunch of char strings being loaded in local variables. Put a breakpoint on <code>.rsrc:01013C49 call $+5</code> and read the strings.</p><ul><li><code>%USERPROFILE%</code></li><li><code>\flareon2016challenge</code></li><li><code>ImageHlp.dll</code></li><li><code>CheckSumMappedFile</code></li><li><code>user32.dll</code></li><li><code>MessageBoxA</code></li></ul><p>It might be looking for a file.</p><p>Let&rsquo;s run procmon again but look for the <code>%USERPROFILE%</code> path which is <code>C:\Users\YouUser</code>.</p><p>Don&rsquo;t be fooled by looking for the <code>notepad.exe.local</code> file, it&rsquo;s a Windows thing <a href=https://blogs.msdn.microsoft.com/junfeng/2006/01/24/dotlocal-local-dll-redirection/>https://blogs.msdn.microsoft.com/junfeng/2006/01/24/dotlocal-local-dll-redirection/</a>.</p><p>Nothing is found, let&rsquo;s dig deeper.</p><p>After loading the strings, <code>sub_10153D0</code> is called.</p><p>The first thing it does is call <code>sub_10153C0</code> which is pretty simple.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>sub_10153C0</span> <span style=color:#268bd2>proc</span> <span style=color:#268bd2>near</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, <span style=color:#268bd2>large</span> <span style=color:#b58900>fs</span>:<span style=color:#2aa198>30h</span>
<span style=color:#268bd2>retn</span>
<span style=color:#268bd2>sub_10153C0</span> <span style=color:#268bd2>endp</span>
</code></pre></div><p>This functions returns the Process Environment Block (PEB).</p><p>This can be later used to get information like &ldquo;isBeingDebugged.&rdquo;</p><p>Flare people like their Anti-debugging techniques.</p><p><a href=https://parsiya.net/images/2014/flare/7-4.jpg>https://parsiya.net/images/2014/flare/7-4.jpg</a></p><p>More info about PEB: <a href=https://www.aldeid.com/wiki/PEB-Process-Environment-Block>https://www.aldeid.com/wiki/PEB-Process-Environment-Block</a></p><p>PEB is then stored in var4 and eax.</p><p>mov ecx, [eax+0Ch]</p><p>Loads byte 12 (0x0C) of PEB into ecx. Which is <code>0x00c _PEB_LDR_DATA* Ldr;</code>.</p><p>According to this link <a href=https://www.aldeid.com/wiki/PEB_LDR_DATA>https://www.aldeid.com/wiki/PEB_LDR_DATA</a> it&rsquo;s:</p><p>&ldquo;The PEB_LDR_DATA structure is a structure that contains information about all of the loaded modules in the current process.&rdquo;</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> _PEB_LDR_DATA
{
    <span style=color:#2aa198>0x00</span>    ULONG         Length;                            <span style=color:#586e75>/* Size of structure, used by ntdll.dll as structure version ID */</span>
    <span style=color:#2aa198>0x04</span>    BOOLEAN       Initialized;                       <span style=color:#586e75>/* If set, loader data section for current process is initialized */</span>
    <span style=color:#2aa198>0x08</span>    PVOID         SsHandle;
    <span style=color:#2aa198>0x0c</span>    LIST_ENTRY    InLoadOrderModuleList;             <span style=color:#586e75>/* Pointer to LDR_DATA_TABLE_ENTRY structure. Previous and next module in load order */</span>
    <span style=color:#2aa198>0x14</span>    LIST_ENTRY    InMemoryOrderModuleList;           <span style=color:#586e75>/* Pointer to LDR_DATA_TABLE_ENTRY structure. Previous and next module in memory placement order */</span>
    <span style=color:#2aa198>0x1c</span>    LIST_ENTRY    InInitializationOrderModuleList;   <span style=color:#586e75>/* Pointer to LDR_DATA_TABLE_ENTRY structure. Previous and next module in initialization order */</span>
} PEB_LDR_DATA,<span style=color:#719e07>*</span>PPEB_LDR_DATA; <span style=color:#586e75>// +0x24
</span></code></pre></div><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>14h</span>]
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>], <span style=color:#b58900>edx</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>]
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_8</span>], <span style=color:#b58900>eax</span>
</code></pre></div><p>Then byte 20 (0x14) is loaded into edx. According to our source this is <code>InMemoryOrderModuleList</code>.</p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx</a></p><p>&ldquo;The head of a doubly-linked list that contains the loaded modules for the process. Each item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure. For more information, see Remarks.&rdquo;</p><p>So the process wants to enumerate all loaded modules.</p><p>Loaded into varC and then var8.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>28h</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_1015270</span>
</code></pre></div><p>Byte 40 is pushed to stack to be called for <code>sub_1015270</code>. If I am not mistaken it&rsquo;s <code>FullDllName</code>.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[<span style=color:#2aa198>2</span>];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[<span style=color:#2aa198>2</span>];
    PVOID DllBase;
    PVOID EntryPoint;
    PVOID Reserved3;
    UNICODE_STRING FullDllName;
    BYTE Reserved4[<span style=color:#2aa198>8</span>];
    PVOID Reserved5[<span style=color:#2aa198>3</span>];
    <span style=color:#719e07>union</span> {
        ULONG CheckSum;
        PVOID Reserved6;
    };
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, <span style=color:#719e07>*</span>PLDR_DATA_TABLE_ENTRY;
</code></pre></div><p>With <code>LIST_ENTRY</code> being 8 bytes in a 32-bit binary (a struct of 2 pointers).</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> _LIST_ENTRY {
   <span style=color:#719e07>struct</span> _LIST_ENTRY <span style=color:#719e07>*</span>Flink;
   <span style=color:#719e07>struct</span> _LIST_ENTRY <span style=color:#719e07>*</span>Blink;
} LIST_ENTRY, <span style=color:#719e07>*</span>PLIST_ENTRY, <span style=color:#719e07>*</span>RESTRICTED_POINTER PRLIST_ENTRY;
</code></pre></div><p>But we do not need any of these.</p><p>Later we see:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_1015270</span>
</code></pre></div><p>edx here is <code>filename</code> which in our case <code>notepad.exe</code>. Remember it&rsquo;s unicode so we will see <code>00</code> between characters. <code>0</code> in ASCII-HEX is <code>0x30</code> but in Unicode it&rsquo;s <code>0x0030</code>.</p><p>So we are running <code>sub_1015270("notepad.exe")</code>.</p><h3 id=sub_1015270>sub_1015270</h3><pre><code>before loop:
var4 = 0

for char in filename:
  edx  = var4
  edx  = edx shr 0x0D
  eax  = var4
  eax  = eax shl 0x13
  edx  = edx or eax
  var4 = edx
  ecx  = var4
  ecx  = ecx add char
  var4 = ecx
</code></pre><p>We want this calculation done on filename to be the same result as <code>0x8FECD63F</code>.</p><p>In case of <code>notepad.exe</code> it will be <code>0xD589DE91</code>.</p><p>The thing that I initially missed was that this iterates over the names of all loaded modules so it&rsquo;s looking for a specific module.</p><p>I thought we needed the file to have a specific name that resulted in that result.</p><p>But the address space is pretty big. Assuming we have 7 spaces and each char could one of 80. It will be 80^7 or 20+ billion.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_10153F0:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>28h</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_1015270</span>
<span style=color:#268bd2>cmp</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_0</span>]
<span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_101540B</span>
</code></pre></div><p>Change <code>eax</code> to <code>0x8FECD63F</code> and continue.</p><p>Then we get to</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_C</span>] <span style=color:#586e75>; &lt;--- put a breakpoint here and run until this triggers.</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>eax</span><span style=color:#719e07>+</span><span style=color:#2aa198>10h</span>]
<span style=color:#268bd2>jmp</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1015424</span>
</code></pre></div><p>varC is <code>InMemoryOrderModuleList</code> and byte 0x10 of it is <code>PVOID DllBase;</code></p><p>Now we can look to the right in IDA under <code>Modules</code> and find out what module satisfied the constraint.</p><p>It was loading <code>C:\Windows\syswow64\kernel32.dll (Base) 77430000 (Size) 00110000</code></p><p>Each pointer is 4 bytes.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[<span style=color:#2aa198>2</span>];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[<span style=color:#2aa198>2</span>];
    PVOID DllBase;      <span style=color:#586e75>// +0x10
</span><span style=color:#586e75></span>    PVOID EntryPoint;
    PVOID Reserved3;
    UNICODE_STRING FullDllName;
    BYTE Reserved4[<span style=color:#2aa198>8</span>];
    PVOID Reserved5[<span style=color:#2aa198>3</span>];
    <span style=color:#719e07>union</span> {
        ULONG CheckSum;
        PVOID Reserved6;
    };
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, <span style=color:#719e07>*</span>PLDR_DATA_TABLE_ENTRY;
</code></pre></div><p>In this case <code>DllBase</code> is <code>0x77430000</code>.</p><p><strong>Back to Main</strong></p><p>var1EC = 0x77430000</p><p><code>sub_1015310(0x77430000, 0x63D6C065)</code></p><h3 id=sub_1015310dllbase-0x63d6c065>sub_1015310(Dllbase, 0x63D6C065)</h3><p>var10 = arg0 = DllBase = 77430000</p><p>var1C = 77430000 + [0x7743003C] = 774300E8</p><p>What is at byte <code>0x3C</code> of <code>kernel32.dll</code>?</p><p>That is the pointer that points to the start of PE header.</p><p>&ldquo;At offset 60 (0x3C) from the beginning of the DOS header is a pointer to the Portable Executable (PE) File header (e_lfanew in MZ structure). DOS will print the error message and terminate, but Windows will follow this pointer to the next batch of information.&rdquo;</p><p>Source: <a href=https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files#PE_Header>https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files#PE_Header</a></p><p>Seems like we are trying to jump over the DOS header.</p><p>ecx = 0x77430000</p><p>add ecx, [eax+78h]</p><p>eax points to the start of the PE header (e.g. the chars PE). What is at offset <code>0x78</code> of PE? In other words offset <code>0x160</code> of DLL. In this case it&rsquo;s <code>0xE0</code>.</p><p>var18 = ecx = 0x774F01E0 and according to IDA this points to <code>kernel32_NlsUpdateSystemLocale+C8E</code>.</p><p>This keeps reading and reading. We need to go down and see what happens in the end.</p><p>We take the first left branch</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>.rsrc:01015384 <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_20</span>]
.rsrc:01015387 <span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>      <span style=color:#586e75>; &lt;--- &#34;acquireSRW&#34;</span>
.rsrc:01015388 <span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_10152C0</span>
.rsrc:0101538<span style=color:#268bd2>D</span> <span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_4</span>], <span style=color:#b58900>eax</span>
</code></pre></div><p>sub_10152C0 with acquiresSRW return <code>0xA77D8D5A</code>.</p><p>Return result of this function is <code>0x7744E296</code> which points to <code>kernel32_FindFirstFileA</code>.</p><p><strong>Back to Main</strong></p><p>var78 = 0x7744E296 = kernel32_FindFirstFileA</p><p>var74 = 0x7746D56E = kernel32_FindNextFileA</p><p><strong>Let&rsquo;s go back and run procmon again.</strong></p><p>This time we add a new filter <code>Result is NAME NOT FOUND</code>.</p><p>We see this line:</p><pre><code>5:15:14.7189299 AM  notepad.exe 3444  IRP_MJ_CREATE C:\Users\x64\flareon2016challenge NAME NOT FOUND  Desired Access: Read Data/List Directory, Synchronize, Disposition: Open, Options: Directory, Synchronous IO Non-Alert, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
</code></pre><p>We have already seen this string at the start.</p><p>Let&rsquo;s create this directory and run it again.</p><p>Seems like it&rsquo;s trying to list everything in the directory now (don&rsquo;t forget to remember the result filter in procmon).</p><pre><code>5:19:02.2219578 AM  notepad.exe 3472  IRP_MJ_CREATE C:\Users\x64\flareon2016challenge SUCCESS Desired Access: Read Data/List Directory, Synchronize, Disposition: Open, Options: Directory, Synchronous IO Non-Alert, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a, OpenResult: Opened
5:19:02.2219763 AM  notepad.exe 3472  IRP_MJ_DIRECTORY_CONTROL  C:\Users\x64\flareon2016challenge\* SUCCESS Type: QueryDirectory, Filter: *, 2: .
5:19:02.2219907 AM  notepad.exe 3472  IRP_MJ_DIRECTORY_CONTROL  C:\Users\x64\flareon2016challenge SUCCESS Type: QueryDirectory, 1: ..
5:19:02.2219999 AM  notepad.exe 3472  IRP_MJ_DIRECTORY_CONTROL  C:\Users\x64\flareon2016challenge NO MORE FILES Type: QueryDirectory
5:19:02.2220071 AM  notepad.exe 3472  IRP_MJ_CLEANUP  C:\Users\x64\flareon2016challenge SUCCESS 
5:19:02.2220138 AM  notepad.exe 3472  IRP_MJ_CLOSE  C:\Users\x64\flareon2016challenge SUCCESS 
</code></pre><p>Let&rsquo;s put a couple of files there and try again. nem1.txt and nem2.txt.</p><p>We can see that it reads the files. It&rsquo;s probably listing the directory, going through all files and looking for something.</p><pre><code>12:54:29.8193558 PM notepad.exe 932 IRP_MJ_CREATE C:\Users\x64\flareon2016challenge\nem1.txt  SUCCESS Desired Access: Generic Read/Write, Disposition: Open, Options: Synchronous IO Non-Alert, Non-Directory File, Attributes: N, ShareMode: None, AllocationSize: n/a, OpenResult: Opened
</code></pre><p>This is where the file is being read. Double click on it and go to the stack tab. We can see where it&rsquo;s being called.</p><pre><code>22  notepad.exe notepad.exe + 0x14e54 0x1014e54 C:\Users\x64\Desktop\4-notepad\notepad.exe
23  notepad.exe notepad.exe + 0x14290 0x1014290 C:\Users\x64\Desktop\4-notepad\notepad.exe
24  notepad.exe notepad.exe + 0x13efa 0x1013efa C:\Users\x64\Desktop\4-notepad\notepad.exe
</code></pre><h3 id=sub_1014e20>sub_1014E20</h3><p>var44 = CreateFileA(FileInDirectory)
var38 = GetFileSize(var44)
var40 = CreateFileMapping(var44)
var4C = MapViewOfFile(var44)</p><h4 id=mapviewoffile>MapViewOfFile</h4><p>If the function succeeds, the return value is the starting address of the mapped view.</p><p>An application can treat a memory mapped file like memory. Meaning it can read and write on it like memory while the file is actually on disk.</p><p>For more info see here: <a href=https://msdn.microsoft.com/en-us/library/ms810613.aspx>https://msdn.microsoft.com/en-us/library/ms810613.aspx</a> under <code>What Are Memory-Mapped Files?</code></p><h3 id=back-to-sub_1014e20>Back to sub_1014E20</h3><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>rsrc:01014<span style=color:#268bd2>EAD</span> <span style=color:#268bd2>loc_1014EAD</span>:                 <span style=color:#586e75>; CODE XREF: sub_1014E20+77</span>
.rsrc:01014<span style=color:#268bd2>EAD</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
.rsrc:01014<span style=color:#268bd2>EAF</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
.rsrc:01014<span style=color:#268bd2>EB1</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
.rsrc:01014<span style=color:#268bd2>EB3</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>2</span>
.rsrc:01014<span style=color:#268bd2>EB5</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_40</span>]
.rsrc:01014<span style=color:#268bd2>EB8</span> <span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>
.rsrc:01014<span style=color:#268bd2>EB9</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_0</span>]
.rsrc:01014<span style=color:#268bd2>EBC</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>eax</span><span style=color:#719e07>+</span><span style=color:#2aa198>18h</span>]
.rsrc:01014<span style=color:#268bd2>EBF</span> <span style=color:#268bd2>call</span>    <span style=color:#b58900>ecx</span>                  <span style=color:#586e75>; MapViewOfFile</span>
.rsrc:01014<span style=color:#268bd2>EC1</span> <span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4C</span>], <span style=color:#b58900>eax</span>    <span style=color:#586e75>; handle to file</span>
.rsrc:01014<span style=color:#268bd2>EC4</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4C</span>]
.rsrc:01014<span style=color:#268bd2>EC7</span> <span style=color:#268bd2>movsx</span>   <span style=color:#b58900>eax</span>, <span style=color:#dc322f>word</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>edx</span>]  <span style=color:#586e75>; first two bytes (e.g. word) are read and put in eax</span>
.rsrc:01014<span style=color:#268bd2>ECA</span> <span style=color:#268bd2>cmp</span>     <span style=color:#b58900>eax</span>, <span style=color:#2aa198>5A4Dh</span>
.rsrc:01014<span style=color:#268bd2>ECF</span> <span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014EFC</span>
</code></pre></div><p>The result of MapViewOfFile is passed to var4C. First two bytes are moved to eax and then compared with <code>0x5A4D</code>. Remember that the first char goes into the lower bytes so it&rsquo;s looking for a file that starts with <code>4D 5A</code>. This is the classic <code>MZ</code> header. Is it looking for a executable?</p><p>Let&rsquo;s change our first file and add <code>MZ</code> to its start.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_1014EFC:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4C</span>]   <span style=color:#586e75>; ecx = handle to file</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_1C</span>], <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_1C</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>edx</span><span style=color:#719e07>+</span><span style=color:#2aa198>3Ch</span>]      <span style=color:#586e75>; load byte 0x3C of the file into eax</span>
<span style=color:#268bd2>cmp</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_38</span>]   <span style=color:#586e75>; var38 = FileSize</span>
<span style=color:#268bd2>jge</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014F51</span>
</code></pre></div><p>We already know what&rsquo;s at <code>0x3C</code> of PE. That is the pointer that points to the start of PE header. Not this is actually 4 bytes (e.g. you will see <code>3C 00 00 00</code>). In this case (and probably in most cases this is just a single byte. If this says <code>0xF0</code> you go to that offset in file and get the PE header.</p><p>It&rsquo;s checking that the pointer is larger than filesize. In other words, it&rsquo;s trying to detect if it&rsquo;s a legit executable file (or a fake file like ours which only has the first few bytes in the header).</p><h3 id=pe-header-detour>PE Header detour</h3><p>This is probably the best resource out there for it. <a href=https://msdn.microsoft.com/en-us/library/ms809762.aspx>https://msdn.microsoft.com/en-us/library/ms809762.aspx</a></p><p>This is also good because it details the different fields and other stuff: <a href=https://www.curlybrace.com/archive/PE%20File%20Structure.pdf>https://www.curlybrace.com/archive/PE%20File%20Structure.pdf</a></p><p>More info (this is why app uses imagehlp.dll): <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx</a></p><p>I am going to come back up here and update the info.</p><p>We will use <code>calc.exe</code> (Windows 7 version) as example.</p><h4 id=mz-header>MZ Header</h4><pre><code>00000000  4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00  |MZ..........ÿÿ..|
00000010  b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  |¸.......@.......|
00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00000030  00 00 00 00 00 00 00 00 00 00 00 00 f0 00 00 00  |............ð...|
</code></pre><p>The fields we are interested in are:</p><ul><li>MZ header: <code>4D5A</code> or <code>MZ</code></li><li>Last page size: <code>0090</code></li><li>Total pages in file: <code>0003</code></li><li>Pointer to PE header: <code>000000F0</code> (at <code>0x3C</code>)</li></ul><h4 id=pe-header>PE Header</h4><p>You can view the PE header in <code>PE Studio</code> under <code>File header</code>.</p><p>Also see this <a href=https://github.com/zed-0xff/pedump>https://github.com/zed-0xff/pedump</a>. The example in readme is calc.exe which is what we are using.</p><pre><code>00000000  50 45 00 00 64 86 06 00 d4 c9 5b 4a 00 00 00 00  |PE..d...ÔÉ[J....|
00000010  00 00 00 00 f0 00 22 00 0b 02 09 00 00 0e 06 00  |....ð.&quot;.........|
00000020  00 f2 07 00 00 00 00 00 b8 b9 01 00 00 10 00 00  |.ò......¸¹......|
00000030  00 00 00 00 01 00 00 00 00 10 00 00 00 02 00 00  |................|
</code></pre><p>First 4 bytes are the PE signature (or header whatever)</p><ul><li>00: <code>504500</code> - PE signature <code>PE 00 00</code></li></ul><p>Then we have the Image file header. See here for everything: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v=vs.85).aspx</a></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> _IMAGE_FILE_HEADER {
  WORD  Machine;
  WORD  NumberOfSections;
  DWORD TimeDateStamp;
  DWORD PointerToSymbolTable;
  DWORD NumberOfSymbols;
  WORD  SizeOfOptionalHeader;
  WORD  Characteristics;
} IMAGE_FILE_HEADER, <span style=color:#719e07>*</span>PIMAGE_FILE_HEADER;
</code></pre></div><ul><li>04: <code>86 64</code> - <code>Machine</code>. In this case it means x64 (IMAGE_FILE_MACHINE_AMD64). <code>01 4C</code>: x86 - <code>02 00</code> Intel Itanium (IA64).</li><li>06: <code>00 06</code> - Number of sections.</li><li>08: <code>4A 5B C9 D4</code> - &ldquo;The low 32 bits of the time stamp of the image. This represents the date and time the image was created by the linker.&rdquo; In this case the timestamp is <code>Mon 13 July 2009 23:57:08 UTC</code>.<ul><li><p>The recipe in CyberChef is (if you copy paste the bytes from hex editor):</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  { <span style=color:#268bd2>&#34;op&#34;</span>: <span style=color:#2aa198>&#34;Swap endianness&#34;</span>,
    <span style=color:#268bd2>&#34;args&#34;</span>: [<span style=color:#2aa198>&#34;Hex&#34;</span>, <span style=color:#2aa198>4</span>, <span style=color:#cb4b16>true</span>] },
  { <span style=color:#268bd2>&#34;op&#34;</span>: <span style=color:#2aa198>&#34;From Base&#34;</span>,
    <span style=color:#268bd2>&#34;args&#34;</span>: [<span style=color:#2aa198>16</span>] },
  { <span style=color:#268bd2>&#34;op&#34;</span>: <span style=color:#2aa198>&#34;From UNIX Timestamp&#34;</span>,
    <span style=color:#268bd2>&#34;args&#34;</span>: [<span style=color:#2aa198>&#34;Seconds (s)&#34;</span>] }
]
</code></pre></div></li></ul></li></ul><h3 id=back-to-sub_1014e20-1>Back to sub_1014E20</h3><p><strong>Perhaps it&rsquo;s trying to execute one of the files from the previous year&rsquo;s challenge.</strong></p><p>Now this works for our small 4-5 char file because there&rsquo;s nothing at that location and it returns 0. 0 is smaller than filesize so it passes the check.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>.rsrc:01014<span style=color:#268bd2>F0D</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_1C</span>]
.rsrc:01014<span style=color:#268bd2>F10</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4C</span>]
.rsrc:01014<span style=color:#268bd2>F13</span> <span style=color:#268bd2>add</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>3Ch</span>]
.rsrc:01014<span style=color:#268bd2>F16</span> <span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_5C</span>], <span style=color:#b58900>edx</span>
.rsrc:01014<span style=color:#268bd2>F19</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_5C</span>]
.rsrc:01014<span style=color:#268bd2>F1C</span> <span style=color:#268bd2>cmp</span>     <span style=color:#dc322f>dword</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>eax</span>], <span style=color:#2aa198>4550h</span>
.rsrc:01014<span style=color:#268bd2>F22</span> <span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014F4F</span>
</code></pre></div><p>Next check is simple. It checks if the data at the start of the PE header is actually <code>0x4550</code> (or PE)</p><p>Let&rsquo;s restart but put an actual executable in the directory. I used <code>calc.exe</code>.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>.rsrc:01014<span style=color:#268bd2>F7C</span>
.rsrc:01014<span style=color:#268bd2>F7C</span> <span style=color:#268bd2>loc_1014F7C</span>:           <span style=color:#586e75>; CODE XREF: sub_1014E20:loc_1014F4F</span>
.rsrc:01014<span style=color:#268bd2>F7C</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_5C</span>]
.rsrc:01014<span style=color:#268bd2>F7F</span> <span style=color:#268bd2>movzx</span>   <span style=color:#b58900>edx</span>, <span style=color:#dc322f>word</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>4</span>]
.rsrc:01014<span style=color:#268bd2>F83</span> <span style=color:#268bd2>cmp</span>     <span style=color:#b58900>edx</span>, <span style=color:#2aa198>14Ch</span>
.rsrc:01014<span style=color:#268bd2>F89</span> <span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014F97</span>
</code></pre></div><p>var5C is start of PE header (from last check).</p><p>It checks if bytes 4 and 5 (starting from 0) after PE header are <code>0x4C</code> and <code>0x01</code>. See above in PE header for explanation. This is checking if this is a x86 executable. In our case, calc is for a 64-bit machine so it will read <code>86 64</code> (<code>64 86</code> in hex editor). For now we can just change it and see what happens later.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_5C</span>]
<span style=color:#268bd2>movzx</span>   <span style=color:#b58900>ecx</span>, <span style=color:#dc322f>word</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>eax</span><span style=color:#719e07>+</span><span style=color:#2aa198>16h</span>]
<span style=color:#268bd2>and</span>     <span style=color:#b58900>ecx</span>, <span style=color:#2aa198>2</span>
<span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014FC2</span>
</code></pre></div><p>Then it loads the byte at PEHeader+22 (<code>0x16</code>) and ands it with 2, if the result is zero we take the bad path. For calc it&rsquo;s <code>0x22</code> and we are safe. The only time something AND 2 is not zero, is when the first two bits of the byte at that number are not 11.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_1014FC2:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_4C</span>]   <span style=color:#586e75>; push *file</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_5C</span>]   <span style=color:#586e75>; push *PEHeader</span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>eax</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_0</span>]    <span style=color:#586e75>; push arg0 </span>
<span style=color:#268bd2>push</span>    <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_10146C0</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_50</span>], <span style=color:#b58900>eax</span>
<span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_50</span>], <span style=color:#2aa198>2</span>
<span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1015008</span>
</code></pre></div><h3 id=sub_10146c0>sub_10146C0</h3><p>Bunch of new strings at start.</p><ul><li><code>\key.bin</code></li><li><code>%USERPROFILE%</code></li><li><code>\flareon2016challenge</code></li><li><code></code>(space or 0x20)</li><li><code>where's my key file?</code></li><li><code>what's wrong with my key file?</code></li><li><code>37E7D8BE7A533025BB38572697266F50F47567BFB0EFA57A65AEAB6673A0A3A140F60C</code> this byte sequence</li></ul><p>Then this function is called <code>kernel32_ExpandEnvironmentStringsA</code></p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724265(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724265(v=vs.85).aspx</a></p><p>Changes the value of an environment-variable for the current user.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>DWORD WINAPI <span style=color:#268bd2>ExpandEnvironmentStrings</span>(
  _In_      LPCTSTR lpSrc,
  _Out_opt_ LPTSTR  lpDst,
  _In_      DWORD   nSize
);
</code></pre></div><p>In this case it&rsquo;s called like this <code>ExpandEnvironmentStrings(%USERPROFILE% ,0x0CF86C , 0x104)</code></p><p>Seems like it could not modify the variable.</p><p>var244 = var240 = &ldquo;\flareon2016challenge&rdquo;</p><p>Then we go through the previous string. Nothing is changed.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_1014A00:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_240</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>cl</span>, [<span style=color:#b58900>eax</span>]
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_245</span>], <span style=color:#b58900>cl</span>
<span style=color:#268bd2>add</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_240</span>], <span style=color:#2aa198>1</span>
<span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_245</span>], <span style=color:#2aa198>0</span>
<span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014A00</span>
</code></pre></div><p>Same thing happens to <code>c:\users\x64</code> or value of %USERPROFILE%.</p><p>We see the string <code>%USERPROFILE%\flareon2016challenge\key.bin</code> being formed. This is likely the name of the key file.</p><p>Then it loads up <del>calc</del> notepad.exe (the file that is being executed). Loads 4 bytes (dword) at <code>*PEHeader+8</code> and compares them to <code>0x48025287</code>.</p><p>This timestamp corresponds to <code>Mon 13 July 2009 23:57:08 UTC</code>. Which the timestamp of the original notepad.exe file.</p><p>See: <a href="https://gchq.github.io/CyberChef/#recipe=From_Base(16)From_UNIX_Timestamp('Seconds%20(s)')&input=NDgwMjUyODc">https://gchq.github.io/CyberChef/#recipe=From_Base(16)From_UNIX_Timestamp('Seconds%20(s)')&input=NDgwMjUyODc</a></p><p>Then it checks the timestamp of the executable in the directory against <code>57D1B2A2</code>.</p><p>Next check is against <code>57D1B2A2</code> or <code>Thu 8 September 2016 18:49:06 UTC</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_4</span>]
<span style=color:#268bd2>cmp</span>     <span style=color:#dc322f>dword</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>8</span>], <span style=color:#2aa198>57D1B2A2h</span>  <span style=color:#586e75>; remember endian-ness. In hex editor you will see A2 B2 D1 57</span>
<span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014BC3</span>
</code></pre></div><p>Let&rsquo;s modify the timestamp of calc.exe to that.</p><p>This time do not debug and just run notepad.exe with the modified calc.exe in the binary.</p><p>We get a timestamp with this <code>2016/09/08 18:49:06 UTC</code>.</p><p>Which is the same as the timestamp of modified calc.exe. This corresponds to the next check that says we need to change the timestamp of notepad.exe to that.</p><p>But before that let&rsquo;s go a bit down that rabbit hole.</p><p>Running procmon we can see that the rest of the files in the directory are still accessed. Maybe we are missing something.</p><p>It actually writes to the files. It writes something from the executable (in the case of our calc it&rsquo;s L32.DLL0x00 which is 8 bytes). It writes it 5 times into the key file (appends it if that matters). It writes 8 bytes from offset 0x400 of calc.</p><p>Let&rsquo;s get the <code>flareon2016challenge.dll</code> from the last year and try it. It seems like we need to change the timestamp though.</p><p>Run notepad, we get the thing. Inside the newly created keyfile we see <code>55 8B EC 83 EC 10 83 7D</code>. This is at offset 0x400 of the DLL.</p><p>But what if we put a copy of notepad.exe there, change the timestamp and ran the original.</p><p>With notepad we get <code>EF 6F DD 77 17 6C DD 77</code>.</p><p>If we change the timestamp of notepad.exe to that, we get to a branch where the timestamp of calc is checked against <code>Fri 9 September 2016 12:54:16 UTC</code> or <code>57D2B0F8</code>. If we do so, we will get a message box with <code>2016/09/09 12:54:16 UTC</code> (which is the same as the timestamp).</p><p>This time 8 bytes from offset 0x410 are appended to the key file.</p><p>Now we need to change the notepad timestamp to <code>57D2B0F8</code> but we are in IDA and we can just move around.</p><p>Just by looking at code we should understand that this time 8 bytes from offset 0x420 are copied to bin.</p><p>Next one is <code>579E9100</code> which copies 8 bytes from offset 0x430. <code>2016/08/01 00:00:00 UTC</code></p><p>And finally everything in the key file gets XOR-ed with that string and shown in the message box.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_1014D19:
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_204</span>]
<span style=color:#268bd2>cmp</span>     <span style=color:#dc322f>dword</span> <span style=color:#268bd2>ptr</span> [<span style=color:#b58900>edx</span><span style=color:#719e07>+</span><span style=color:#2aa198>8</span>], <span style=color:#2aa198>579E9100h</span>
<span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>loc_1014E09</span>
</code></pre></div><p>This time stamp is <code>Mon 1 August 2016 00:00:00 UTC</code>.</p><p><a href="https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',4,true)From_Base(16)From_UNIX_Timestamp('Seconds%20(s)')&input=MDAgOTEgOUUgNTc">https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',4,true)From_Base(16)From_UNIX_Timestamp('Seconds%20(s)')&input=MDAgOTEgOUUgNTc</a></p><p>Now it calls <code>CreateFileA</code> and looks for <code>key.bin</code>. Because it does not exist, it will take the bad path.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>.rsrc:01014<span style=color:#268bd2>D2C</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
.rsrc:01014<span style=color:#268bd2>D2E</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>80h</span>
.rsrc:01014<span style=color:#268bd2>D33</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>3</span>
.rsrc:01014<span style=color:#268bd2>D35</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
.rsrc:01014<span style=color:#268bd2>D37</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
.rsrc:01014<span style=color:#268bd2>D39</span> <span style=color:#268bd2>push</span>    <span style=color:#2aa198>80000000h</span>
.rsrc:01014<span style=color:#268bd2>D3E</span> <span style=color:#268bd2>lea</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_170</span>]
.rsrc:01014<span style=color:#268bd2>D44</span> <span style=color:#268bd2>push</span>    <span style=color:#b58900>eax</span>
.rsrc:01014<span style=color:#268bd2>D45</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_0</span>]
.rsrc:01014<span style=color:#268bd2>D48</span> <span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>10h</span>]
.rsrc:01014<span style=color:#268bd2>D4B</span> <span style=color:#268bd2>call</span>    <span style=color:#b58900>edx</span>
.rsrc:01014<span style=color:#268bd2>D4D</span> <span style=color:#268bd2>mov</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_60</span>], <span style=color:#b58900>eax</span>
.rsrc:01014<span style=color:#268bd2>D50</span> <span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_60</span>], <span style=color:#2aa198>0FFFFFFFFh</span>
.rsrc:01014<span style=color:#268bd2>D54</span> <span style=color:#268bd2>jnz</span>     <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014D83</span>
</code></pre></div><p>Looking back at the MSDN link for CreateFile we can see what is being pushed.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>CreateFile(hTemplateFile <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>,
    dwFlagsAndAttributes <span style=color:#719e07>=</span> <span style=color:#2aa198>0x80</span>, <span style=color:#586e75>// FILE_ATTRIBUTE_NORMAL - The file does not have other attributes set. This attribute is valid only if used alone.
</span><span style=color:#586e75></span>    dwCreationDisposition<span style=color:#719e07>=</span> <span style=color:#2aa198>0x03</span>, <span style=color:#586e75>// OPEN_EXISTING
</span><span style=color:#586e75></span>    lpSecurityAttributes <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>,    <span style=color:#586e75>// The handle returned by CreateFile cannot be inherited by any child processes the application
</span><span style=color:#586e75></span>    dwShareMode          <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>,    <span style=color:#586e75>// Prevents other processes from opening a file or device if they request delete, read, or write access.
</span><span style=color:#586e75></span>    dwDesiredAccess<span style=color:#719e07>=</span> <span style=color:#2aa198>0x80000000</span>, <span style=color:#586e75>// FILE_FLAG_WRITE_THROUGH - No caching - Write operations will go directly to disk.
</span><span style=color:#586e75></span>    lpFileName           <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;...</span><span style=color:#cb4b16>\\</span><span style=color:#2aa198>flareon2016challenge</span><span style=color:#cb4b16>\\</span><span style=color:#2aa198>key.bin&#34;</span>
    )
</code></pre></div><p>Handle to the key file goes into var60.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_1014D83:
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>0</span>
<span style=color:#268bd2>lea</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_18</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>ecx</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>20h</span>
<span style=color:#268bd2>lea</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_44</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_60</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>eax</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>arg_0</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ecx</span><span style=color:#719e07>+</span><span style=color:#2aa198>60h</span>]
<span style=color:#268bd2>call</span>    <span style=color:#b58900>edx</span>             <span style=color:#586e75>; ReadFile</span>
<span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_18</span>], <span style=color:#2aa198>20h</span>
<span style=color:#268bd2>jz</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_1014DCB</span>
</code></pre></div><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
BOOL WINAPI <span style=color:#268bd2>ReadFile</span>(
  _In_        HANDLE       hFile,                <span style=color:#586e75>// var60 - file handle to key.bin
</span><span style=color:#586e75></span>  _Out_       LPVOID       lpBuffer,             <span style=color:#586e75>// var44 - pointer to an empty buffer?
</span><span style=color:#586e75></span>  _In_        DWORD        nNumberOfBytesToRead, <span style=color:#586e75>// 0x20  - 32 decimal
</span><span style=color:#586e75></span>  _Out_opt_   LPDWORD      lpNumberOfBytesRead,  <span style=color:#586e75>// var18 - which looks like an empty buffer
</span><span style=color:#586e75></span>  _Inout_opt_ LPOVERLAPPED lpOverlapped          <span style=color:#586e75>// 0
</span><span style=color:#586e75></span>);
</code></pre></div><p>So it reads 32 bytes from the key file.</p><p>Let&rsquo;s put some text into the key file and re-run.</p><p><code>012345678901234567890123456789AB</code></p><p>Then it checks if we read 0x20 bytes which we did.</p><p>push 0x20
push
push 0x20
push <code>37E7D8BE7A533025BB38572697266F50F47567BFB0EFA57A65AEAB6673A0A3A140F60C</code> (remember start of the function?)</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>loc_1014DCB:
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>20</span>                <span style=color:#586e75>; most likely the number of bytes we read from key.bin</span>
<span style=color:#268bd2>lea</span>     <span style=color:#b58900>ecx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_44</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>ecx</span>               <span style=color:#586e75>; contents we just read from key.bin</span>
<span style=color:#268bd2>push</span>    <span style=color:#2aa198>20h</span>
<span style=color:#268bd2>lea</span>     <span style=color:#b58900>edx</span>, [<span style=color:#b58900>ebp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_200</span>]
<span style=color:#268bd2>push</span>    <span style=color:#b58900>edx</span>               <span style=color:#586e75>; 37E7D8BE7A533025BB38572697266F50F47567BFB0EFA57A65AEAB6673A0A3A140F60C</span>
<span style=color:#268bd2>call</span>    <span style=color:#268bd2>sub_1014670</span>
</code></pre></div><h3 id=sub_1014670>sub_1014670</h3><p>var4 = 0
cmp with arg4 = 0x20</p><p>check if we read 32 bytes.</p><p>var4 = 0 ; counter?</p><p>edx = *arg0 = or *string
ecx = string[var4]
eax = var4</p><p>cdq = double the size of EAX. Then we will have EDX:EAX to represent stuff.</p><p>idiv edx:eax / argC (last 0x20)</p><p>In this case 0/32 result will be zero.</p><p>I will like that we are just doing some normal string operations and this is standard compiler code. I have seen this before but I don&rsquo;t remember. It&rsquo;s probably just going through the string and parse it.</p><p>eax = *keybin
edx = *keybin[0]</p><p>ecx = ecx xor edx (xor first byte of key with first byte of string)</p><p>store the result in string</p><p>This function just xors byte read from keybin with string (but seems like only does it for 32 bytes). So the last 3 bytes of *string will be untouched.</p><p>push 0
push *var4 = 0x20
push xor-ed string (with last 3 bytes untouched)
push 0</p><p>Call MessageBox and show the result</p><p>So <code>37E7D8BE7A533025BB38572697266F50F47567BFB0EFA57A65AEAB6673A0A3A1</code> gets XOR-ed with 32 bytes in the key.bin file and a message box shows the results.</p><p>Now it did not work with notepad. What about the challenge DLL from last year?</p><p>The bytes are <code>55 8B EC 83 EC 10 83 7D 05 00 00 8D 4A 02 2B D7 8D 77 02 89 55 F4 EB 08 8B 55 F4 0F B6 14 32 0F</code></p><p>And the message box is still garbled although the first 4 bytes look readable <code>bl4=</code>.</p><hr><p>Ok I have been blind.</p><p>We have four timestamps. Look inside last year&rsquo;s challenge and find files with the same timestamp.</p><p>CyberChef example: <a href="https://gchq.github.io/CyberChef/#recipe=From_Base(16)From_UNIX_Timestamp('Seconds%20(s)')&input=NDkxODAxOTI">https://gchq.github.io/CyberChef/#recipe=From_Base(16)From_UNIX_Timestamp('Seconds%20(s)')&input=NDkxODAxOTI</a></p><p>Make sure to either read the timestamp from a hex editor or use something like PEStudio because the one you see in Windows might not be what you are looking for.</p><ul><li><code>57D1B2A2</code> - <code>Thu 8 September 2016 18:49:06 UTC</code> - challenge1.exe</li><li><code>57D2B0F8</code> - <code>Fri 9 September 2016 12:54:16 UTC</code> - DudeLocker.exe (challenge 2)</li><li><code>49180192</code> - <code>Mon 10 November 2008 09:40:34 UTC</code> - khaki.exe (challenge 6)</li><li><code>579E9100</code> - <code>Mon 1 August 2016 00:00:00 UTC</code> - unknown (challenge 3) - Note PEStudio shows the timestamp as July 31st 00.</li></ul><p>Now we need to see which challenge has this timestamp(s) and copy them (or grab the bytes from offset). See they are also sorted alphabetically based on the original files names.</p><p>55 8B EC 8B 4D 0C 56 57
8B 55 08 52 FF 15 30 20
C0 40 50 FF D6 83 C4 08
00 83 C4 08 5D C3 CC CC</p><p>And after the xor we get</p><p><strong><a href=mailto:bl457_fr0m_th3_p457@flare-on.com>bl457_fr0m_th3_p457@flare-on.com</a></strong></p><hr><h1 id=5---pewpewboat>5 - pewpewboat</h1><p>Actually an ELF binary.</p><p>We need to setup remote debugging.</p><p>Setup two VMs, add an &ldquo;internal network&rdquo; card for each with the name <code>intnet</code> (or whatever).</p><p>Then the following command sets up DHCP for that. Now they can talk to each other.</p><pre><code>C:\Program Files\Oracle\VirtualBox&gt;VBoxManage dhcpserver add --netname intnet --ip 192.168.133.100 --netmask 255.255.255.0 --lowerip 192.168.133.101 --upperip 192.168.133.254 --enable
</code></pre><h2 id=recon>recon</h2><h3 id=strings>Strings</h3><p>We got some stuff from strings, some of them look interesting or could be anything.</p><pre><code>allsunk!H9
__libc_start_main
GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609
</code></pre><h3 id=file>file</h3><pre><code>root@kali:~/Desktop/pewpew# file pewpewboat 
pewpewboat: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=580d3cee15362410c9e7b0ae44d65d57deb52912, stripped
</code></pre><h3 id=ldd>ldd</h3><pre><code>root@kali:~/Desktop/pewpew# ldd pewpewboat 
  linux-vdso.so.1 (0x00007fffdd3c4000)
  libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f9b2f977000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9b2f5d9000)
  /lib64/ld-linux-x86-64.so.2 (0x000055fc98ef3000)
</code></pre><h3 id=nm>nm</h3><pre><code>root@kali:~/Desktop/pewpew# nm pewpewboat 
nm: pewpewboat: no symbols
</code></pre><h3 id=readelf>readelf</h3><pre><code>root@kali:~/Desktop/pewpew# readelf -l pewpewboat 

Elf file type is EXEC (Executable file)
Entry point 0x400ae0
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    0x8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000046fc 0x00000000000046fc  R E    0x200000
  LOAD           0x0000000000004e00 0x0000000000604e00 0x0000000000604e00
                 0x000000000000e43c 0x000000000000e458  RW     0x200000
  DYNAMIC        0x0000000000004e18 0x0000000000604e18 0x0000000000604e18
                 0x00000000000001e0 0x00000000000001e0  RW     0x8
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x0000000000003fa0 0x0000000000403fa0 0x0000000000403fa0
                 0x000000000000015c 0x000000000000015c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000004e00 0x0000000000604e00 0x0000000000604e00
                 0x0000000000000200 0x0000000000000200  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .init_array .fini_array .jcr .dynamic .got 

</code></pre><h3 id=strace>strace</h3><p>We can run strace to see system calls. The following options help:</p><ul><li><code>-i</code>: Prints IP at time of syscall - this helps a lot with setting breakpoint.</li><li><code>-s9999</code>: Do not cutout strings in function parameters.</li><li><code>-o outputfile</code>: Store the output in a file - helps with not having the strace output interfere with the game.</li></ul><p>Let&rsquo;s look at the interesting parts.</p><pre><code>[00007fe97405b4f7] execve(&quot;./pewpewboat&quot;, [&quot;./pewpewboat&quot;], [/* 43 vars */]) = 0
[00007ff8d202a619] brk(NULL)            = 0xae4000
[00007ff8d202b347] access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory)

[00007ff8d202b2e7] open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3

[00007ff8d202b347] access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory)
[00007ff8d202b2e7] open(&quot;/lib/x86_64-linux-gnu/libtinfo.so.5&quot;, O_RDONLY|O_CLOEXEC) = 3

[00007ff8d202b2e7] open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3

[00007ff8d1b24f72] fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
[00007ff8d1b25600] write(1, &quot;Loading first pew pew map...\n&quot;, 29) = 29

[00007ff8d1b25380] open(&quot;/lib/terminfo/x/xterm-256color&quot;, O_RDONLY) = 3
[00007ff8d1b255a0] read(3, &quot;&quot;, 4096)    = 0

[00007ff8d1b25600] write(1, &quot;\33[H\33[2J  \33[4m 1 2 3 4 5 6 7 8 \33[0m\n&quot;, 35) = 35
[00007ff8d1b25600] write(1, &quot;A |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;B |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;C |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;D |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;E |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;F |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;G |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;H |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;\n&quot;, 1)    = 1
[00007ff8d1b25600] write(1, &quot;Rank: Seaman Recruit\n\n&quot;, 22) = 22
[00007ff8d1b25600] write(1, &quot;Welcome to pewpewboat! We just loaded a pew pew map, start shootin'!\n&quot;, 69) = 69
[00007ff8d1b25600] write(1, &quot;\n&quot;, 1)    = 1
[00007ff8d1b24f72] fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
[00007ff8d1b25600] write(1, &quot;Enter a coordinate: &quot;, 20) = 20
[00007ff8d1b255a0] read(0, &quot;H9\n&quot;, 1024) = 3

[00007ff8d1b25600] write(1, &quot;\33[H\33[2J  \33[4m 1 2 3 4 5 6 7 8 \33[0m\n&quot;, 35) = 35
[00007ff8d1b25600] write(1, &quot;A |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;B |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;C |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;D |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;E |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;F |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;G |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;H |_|_|_|_|_|_|_|_|\n&quot;, 20) = 20
[00007ff8d1b25600] write(1, &quot;\n&quot;, 1)    = 1
[00007ff8d1b25600] write(1, &quot;Rank: Seaman Recruit\n\n&quot;, 22) = 22
[00007ff8d1b25600] write(1, &quot;You missed :(\n&quot;, 14) = 14
[00007ff8d1b25600] write(1, &quot;\n&quot;, 1)    = 1
[00007ff8d1b25600] write(1, &quot;Enter a coordinate: &quot;, 20) = 20
[00007ff8d1b255a0] read(0, &quot;01234567890123456789\n&quot;, 1024) = 21
[00007ff8d1b25600] write(1, &quot;OjU\221\274\1r\377\334\255qQe\0054P\4\303\377\313i$\323\367MK\345^\217\2666\206G\24\221\355\221\207\2073r\222\33\33\343n\243\252\363I2\274\\O\v\306\252\200P\211\363!\370\245N\274\201\3479S\317\254\210VT\266\320\2105\201P\n&quot;, 82) = 82
[00007ff8d1b329e7] lseek(0, -5, SEEK_CUR) = -1 ESPIPE (Illegal seek)
[00007ff8d1b024c8] exit_group(1)        = ?
[????????????????] +++ exited with 1 +++
</code></pre><p>When we enter a long string it crashes (although it&rsquo;s reading 1024 bytes).</p><pre><code>[00007ff8d1b255a0] read(0, &quot;01234567890123456789\n&quot;, 1024) = 21
[00007ff8d1b25600] write(1, &quot;OjU\221\274\1r\377\334\255qQe\0054P\4\303\377\313i$\323\367MK\345^\217\2666\206G\24\221\355\221\207\2073r\222\33\33\343n\243\252\363I2\274\\O\v\306\252\200P\211\363!\370\245N\274\201\3479S\317\254\210VT\266\320\2105\201P\n&quot;, 82) = 82
[00007ff8d1b329e7] lseek(0, -5, SEEK_CUR) = -1 ESPIPE (Illegal seek)
</code></pre><h3 id=ltrace>ltrace</h3><p>We can run ltrace to get some extra information.</p><pre><code>root@kali:~/Desktop/pewpew# ltrace -iS -s9999 -o ltrace1.txt ./pewpewboat 
Loading first pew pew map...
</code></pre><p>ltrace options are similar. <code>-S</code> also traces system calls.</p><pre><code>...
[0x400b09] __libc_start_main(0x403d86, 1, 0x7fffa84616d8, 0x403f10 &lt;unfinished ...&gt;
[0x403da7] time(0)                                                  = 1506201701
[0x403dae] srand(0x59c6d065, 0x7fffa84616d8, 0x7fffa84616e8, 0)     = 0
[0x403db8] malloc(576 &lt;unfinished ...&gt;
[0x7fb007f52b79] SYS_brk(0)                                         = 0xd47000
[0x7fb007f52b79] SYS_brk(0xd68000)                                  = 0xd68000
[0x403db8] &lt;... malloc resumed&gt; )                                   = 0xd47010
[0x403e4a] printf(&quot;%s&quot;, &quot;Loading first pew pew map...\n&quot; &lt;unfinished ...&gt;
[0x7fb007f4cf72] SYS_fstat(1, 0x7fffa8460e30)                       = 0
[0x7fb007f4d600] SYS_write(1, &quot;Loading first pew pew map...\n&quot;, 29) = 29
[0x403e4a] &lt;... printf resumed&gt; )                                   = 29
[0x403d18] sprintf(&quot;loading... 0%&quot;, &quot;loading... %d%%&quot;, 0)           = 13
[0x402cd8] memcpy(0x7fffa8461498, &quot;loading... %d%%\0&quot;, 16)          = 0x7fffa8461498
[0x402d9d] memset(0x7fffa84614a9, '\0', 39)                         = 0x7fffa84614a9
[0x402fa2] memset(0x7fffa8461480, '\0', 152)                        = 0x7fffa8461480
...
</code></pre><p>And it keeps going on and on.</p><pre><code>[0x403d18] sprintf(&quot;loading... 11032%&quot;, &quot;loading... %d%%&quot;, 11032)   = 17
[0x402cd8] memcpy(0x7fffa8461498, &quot;a1#\326X\375^f\037q\274\276g\266aP&quot;, 16) = 0x7fffa8461498
[0x402d9d] memset(0x7fffa84614a9, '\0', 39)                         = 0x7fffa84614a9
[0x402fa2] memset(0x7fffa8461480, '\0', 152)                        = 0x7fffa8461480
[0x403d18] sprintf(&quot;loading... 11033%&quot;, &quot;loading... %d%%&quot;, 11033)   = 17
[0x402cd8] memcpy(0x7fffa8461498, &quot;\035\a\312\364\034lf\244\316\357\356c\306\256\0\274&quot;, 16) = 0x7fffa8461498
[0x402d9d] memset(0x7fffa84614a9, '\0', 39)                         = 0x7fffa84614a9
[0x402fa2] memset(0x7fffa8461480, '\0', 152)                        = 0x7fffa8461480
</code></pre><p>So there might be some anti-debugging going on?</p><h2 id=detour-to-function-calls-in-x64>Detour to function calls in x64</h2><h3 id=linux>Linux</h3><p>Read these (trust me they are short reads):</p><ul><li><a href=http://wiki.osdev.org/System_V_ABI>http://wiki.osdev.org/System_V_ABI</a></li><li><a href=http://wiki.osdev.org/Calling_Conventions>http://wiki.osdev.org/Calling_Conventions</a> - especially the cheatsheet.</li></ul><p>In x86 function parameters were pushed to the stack from right to left before the <code>call</code>. Remember that return address is pushed to the stack right before call.</p><p>In x64 ABI (Application Binary Interface), we store the first 6 parameters in registers and the rest get pushed to the stack like x86. The registers are <code>rdi, rsi, rdx, rcx, r8, r9</code>.</p><p>For example if we call <code>randomfunc(p1, p2, p3, p4, p5, p6, p7, p8, p9)</code>:</p><ul><li>push p9</li><li>push p8</li><li>push p7</li><li>mov r9, p6</li><li>mov r8, p5</li><li>mov rcx, p4</li><li>mov rdx, p3</li><li>mov rsi, p2</li><li>mov rdi, p1</li></ul><h3 id=windows>Windows</h3><p>It&rsquo;s a bit different.</p><p>Quick read: <a href=https://docs.microsoft.com/en-us/cpp/build/parameter-passing>https://docs.microsoft.com/en-us/cpp/build/parameter-passing</a></p><p>&ldquo;The first four integer arguments are passed in registers. Integer values are passed (in order left to right) in RCX, RDX, R8, and R9. Arguments five and higher are passed on the stack.&rdquo;</p><p>&ldquo;Floating-point and double-precision arguments are passed in XMM0 - XMM3 (up to 4).&rdquo;</p><p>More stuff:</p><ul><li><a href=https://docs.microsoft.com/en-us/cpp/build/calling-convention>https://docs.microsoft.com/en-us/cpp/build/calling-convention</a></li><li><a href=https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions>https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions</a></li></ul><h2 id=remote-debugging-with-ida>Remote debugging with IDA</h2><p>Let&rsquo;s do some remote debugging because I don&rsquo;t <del>like</del> know GDB or r2.</p><p>Put a breakpoint on the <code>rand</code> at <code>0x0x403dae</code> which is actually at the start of <code>main</code>. (DAE ??? lololol eckss deee omg).</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>rax</span>, <span style=color:#b58900>fs</span>:<span style=color:#2aa198>28h</span>      <span style=color:#586e75>; stack canary</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_8</span>], <span style=color:#b58900>rax</span>
</code></pre></div><p>This part is similar to what we have seen in strace output.</p><p>time(0) - seed(time) - malloc(576 - 0x240)</p><p>Then printf("%s", &ldquo;Loading first pew pew map&mldr;\n&rdquo;)</p><p>eax = 0</p><h3 id=call-sub_406c85>call sub_406C85</h3><p>This is where loading happens.</p><p>sprintf(&ldquo;loading&mldr; 0%&rdquo;, &ldquo;loading&mldr; %d%%&rdquo;, 0)</p><p>sub_402FA5</p><p>sub402B31(&ldquo;loading&mldr; %d%%")</p><p>67452301
EFCDAB89
98BADCFE
10325476</p><p>This is the MD5 initialization block.</p><p>0x1D in the end?</p><p>576 or 0x240 bytes from unk_6050E0[rax] are copied.</p><p><code>sub_40304F(unk_6050E0, 0x240, 0x3B1EE5F6B3D99FF7)</code></p><p>var18 = unk
var1C = 0x240
var28 = 0x3B1EE5F6B3D99FF7</p><p>called with var28</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>sub_403034</span> <span style=color:#268bd2>proc</span> <span style=color:#268bd2>near</span>

<span style=color:#268bd2>var_8</span>= <span style=color:#dc322f>qword</span> <span style=color:#268bd2>ptr</span> <span style=color:#719e07>-</span><span style=color:#2aa198>8</span>

<span style=color:#268bd2>push</span>    <span style=color:#b58900>rbp</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>rbp</span>, <span style=color:#b58900>rsp</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_8</span>], <span style=color:#b58900>rdi</span>
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>rax</span>, [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_8</span>]
<span style=color:#268bd2>imul</span>    <span style=color:#b58900>rax</span>, <span style=color:#2aa198>41C64E6Dh</span>
<span style=color:#268bd2>add</span>     <span style=color:#b58900>rax</span>, <span style=color:#2aa198>3039h</span>
<span style=color:#268bd2>pop</span>     <span style=color:#b58900>rbp</span>
<span style=color:#268bd2>retn</span>
</code></pre></div><p>unknown is xor-ed with result of sub_403034(0x3B1EE5F6B3D99FF7).</p><p>Prints the table: sub_403263</p><h3 id=read-input>Read Input</h3><p>Probably should have come here in the first place.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm>.text:0000000000403806 <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rdx</span>, <span style=color:#b58900>cs</span>:<span style=color:#268bd2>stdin</span>                   <span style=color:#586e75>; stream</span>
.text:000000000040380<span style=color:#268bd2>D</span> <span style=color:#268bd2>lea</span>     <span style=color:#b58900>rax</span>, [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>s</span>]
.text:0000000000403811 <span style=color:#268bd2>mov</span>     <span style=color:#b58900>esi</span>, <span style=color:#2aa198>11h</span>                        <span style=color:#586e75>; n</span>
.text:0000000000403816 <span style=color:#268bd2>mov</span>     <span style=color:#b58900>rdi</span>, <span style=color:#b58900>rax</span>                        <span style=color:#586e75>; s</span>
.text:0000000000403819 <span style=color:#268bd2>call</span>    <span style=color:#268bd2>_fgets</span>
</code></pre></div><p>Sub first coordinate from <code>0x41</code> (to get the index from <code>A</code>). Same thing happens with second but with <code>0x31</code> to get the index from <code>1</code>.</p><p>var40 = letter coordinate index from A (e.g. A=0 B=1 and so on).
var4C = number corrdinate index from 0 (e.g. 0=0 1=1 and so on)</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_40</span>], <span style=color:#2aa198>0</span>
<span style=color:#268bd2>js</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_4038B3</span>
</code></pre></div><p>Check if coordinate from A is negative. <code>cmp</code> does a subtract and <code>js</code> jumps if sign flag is set. So if we entered something with a lower ASCII-HEX code than A (<code>0x41</code>) we jump to another place here.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>cmp</span>     [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_40</span>], <span style=color:#2aa198>7</span>
<span style=color:#268bd2>jg</span>      <span style=color:#268bd2>short</span> <span style=color:#268bd2>loc_4038B3</span>
</code></pre></div><p>Check if first coordinate over 7 (e.g. over <code>H</code>).</p><p>Same thing happens with second coordinate (the number).</p><p>var58 = 00 78 08 08 78 08 08 00 01 00 00 00 00 00</p><hr><p>eax = first
edx = eax * 8 = first * 8</p><p>eax = second
eax = second + first * 8
edx = 1
ecx = second + first * 8
var38 = 1 shl cl = 1 shl (second + first * 8)</p><p>rax = var48 = 0008087808087800 = function param
rax = rax[8] = 01 (start from zero)</p><p>rdx = 01 or var38</p><p>var48 = 3B1EE5F6B3D99FF7 always</p><p>breakpoint at</p><pre><code>.text:0000000000403B57 mov     [rbp+var_30], 59h
.text:0000000000403B5B mov     [rbp+var_2F], 6Fh
.text:0000000000403B5F mov     [rbp+var_2E], 75h
</code></pre><h3 id=call----sub_4035300008087808087800>call sub_403530(0008087808087800)</h3><p>var_1A8 = 0008087808087800</p><pre><code>mov     esi, 4
mov     rdi, rax
call    sub_402FA5
</code></pre><p>sub_402FA5(&ldquo;4 rand-ish digits&rdquo;, 4, 1)</p><p>MD5 initialization constants for variables</p><p>sub_402B31</p><pre><code>[stack]:00007FFCC4A6F189 db  23h ; #
[stack]:00007FFCC4A6F18A db  45h ; E
[stack]:00007FFCC4A6F18B db  67h ; g
[stack]:00007FFCC4A6F18C db  89h ; ë
[stack]:00007FFCC4A6F18D db 0ABh ; ½
[stack]:00007FFCC4A6F18E db 0CDh ; -
[stack]:00007FFCC4A6F18F db 0EFh ; n
[stack]:00007FFCC4A6F190 db 0FEh ; ¦
[stack]:00007FFCC4A6F191 db 0DCh ; _
[stack]:00007FFCC4A6F192 db 0BAh ; ¦
[stack]:00007FFCC4A6F193 db  98h ; ÿ
[stack]:00007FFCC4A6F194 db  76h ; v
[stack]:00007FFCC4A6F195 db  54h ; T
[stack]:00007FFCC4A6F196 db  32h ; 2
[stack]:00007FFCC4A6F197 db  10h
</code></pre><p>Read new input</p><p>.text:00000000004036CE call _fgets</p><p>.text:000000000040375E jz short loc_403765</p><p>change to jmp</p><p>0000000000403C77</p><p>00000000004036CB</p><p>F</p><p>b4 b5 b6 b7
c4
d4
e4 e5 e6 e7
f4
g4</p><p>H</p><p>b4 b8
c4 c8
d4 d8
e4 e5 e6 e7 e8
f4 f8
g4 g8</p><p>G</p><p>a2 a3 a4 a5 a6 a7
b1 b8
c1
d1
e1 e5 e6 e7 e8
f1 f8
g1 g8
h2 h3 h4 h5 h6 h7</p><p>U</p><p>d5 d8
e5 e8
f5 f8
g5 g8
h5 h6 h7 h8</p><p>Z</p><p>b4 b5 b6 b7 b8
c7
d6
e5
f4 f5 f6 f7 f8</p><p>R</p><p>a1 a2 a3
b1 b4
c1 c2 c3
d1 d3
e1 e4</p><p>E</p><p>d5 d6 d7
e5
f5 f6 f7
g5
h5 h6 h7</p><p>J</p><p>b2 b3 b4 b5 b6
c4
d4
e4
f1 f4
g2 g3</p><p>V</p><p>d3 d7
e3 e7
f3 f7
g4 g6
h5</p><p>O</p><p>d3 d4
e2 e5
f2 f5
g2 g5
h3 h4</p><pre><code>Rank: Congratulation!

Aye!PEWYouPEWfoundPEWsomePEWlettersPEWdidPEWya?PEWToPEWfindPEWwhatPEWyou'rePEWlookingPEWfor,PEWyou'llPEWwantPEWtoPEWre-orderPEWthem:PEW9,PEW1,PEW2,PEW7,PEW3,PEW5,PEW6,PEW5,PEW8,PEW0,PEW2,PEW3,PEW5,PEW6,PEW1,PEW4.PEWNextPEWyouPEWletPEW13PEWROTPEWinPEWthePEWsea!PEWTHEPEWFINALPEWSECRETPEWCANPEWBEPEWFOUNDPEWWITHPEWONLYPEWTHEPEWUPPERPEWCASE.
Thanks for playing!
</code></pre><p>Replace <code>PEW</code> with space</p><pre><code>Aye! You found some letters did ya? To find what you're looking for, you'll want to re-order them: 9, 1, 2, 7, 3, 5, 6, 5, 8, 0, 2, 3, 5, 6, 1, 4. Next you let 13 ROT in the sea! THE FINAL SECRET CAN BE FOUND WITH ONLY THE UPPER CASE.
</code></pre><p>We got letters</p><p>9, 1, 2, 7, 3, 5, 6, 5, 8, 0, 2, 3, 5, 6, 1, 4</p><p>0 1 2 3 4 5 6 7 8 9
F H G U Z R E J V O</p><p>O H G J U R E R V F G U R E H Z</p><p>BUTWHEREISTHERUM</p><p>Remember when we entered a long string, the binary returned some random shit?</p><p>Enter the secret and we get.</p><pre><code>y0u__sUnK_mY__P3Wp3w_b04t@flare-on.com
</code></pre><p>It was in the damned thing that we found at the start!</p><hr><p>Try two
Choose <code>_fgets</code> in IDA. Select and highlight text <code>_fgets</code> and press X for references. We get two calls.</p><p>First one is for coordinates and second one is for entering the hash.</p><p>After entering a coordinate.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>movzx</span>   <span style=color:#b58900>eax</span>, [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>s</span>]
<span style=color:#268bd2>and</span>     <span style=color:#b58900>eax</span>, <span style=color:#2aa198>0FFFFFFDFh</span>
<span style=color:#268bd2>movsx</span>   <span style=color:#b58900>eax</span>, <span style=color:#b58900>al</span>
<span style=color:#268bd2>sub</span>     <span style=color:#b58900>eax</span>, <span style=color:#2aa198>41h</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>first</span>], <span style=color:#b58900>eax</span>
</code></pre></div><p>First char is changed to uppercase (lowercase - 0x20 = uppercase). If it&rsquo;s already uppercase nothing happens.</p><p>Subtract from 0x41 = offset from A.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>movzx</span>   <span style=color:#b58900>eax</span>, [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>var_2F</span>]
<span style=color:#268bd2>movsx</span>   <span style=color:#b58900>eax</span>, <span style=color:#b58900>al</span>
<span style=color:#268bd2>sub</span>     <span style=color:#b58900>eax</span>, <span style=color:#2aa198>31h</span>
<span style=color:#268bd2>mov</span>     [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>second</span>], <span style=color:#b58900>eax</span>
</code></pre></div><p>Second char (number) from 0x31 (1) to get the offset.</p><p>Then checks if the offsets are in [0,7).</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>first</span>]
<span style=color:#268bd2>lea</span>     <span style=color:#b58900>edx</span>, <span style=color:#b58900>ds</span>:<span style=color:#2aa198>0</span>[<span style=color:#b58900>rax</span><span style=color:#719e07>*</span><span style=color:#2aa198>8</span>]
<span style=color:#268bd2>mov</span>     <span style=color:#b58900>eax</span>, [<span style=color:#b58900>rbp</span><span style=color:#719e07>+</span><span style=color:#268bd2>second</span>]
<span style=color:#268bd2>add</span>     <span style=color:#b58900>eax</span>, <span style=color:#b58900>edx</span>
</code></pre></div><p>eax = offset1 * 8 + offset2 (for example A0 = 0 - H8 = 63)</p><p>Essentially the coordinate is transformed to an index in the 64 cell array that represents the map (starting from 0).</p><p>The coordinates are written in memory just before the rank.</p><pre><code>[heap]:00F7202C db  42h ; B
[heap]:00F7202D db  34h ; 4
[heap]:00F7202E db  53h ; S
[heap]:00F7202F db  65h ; e
[heap]:00F72030 db  61h ; a
[heap]:00F72031 db  6Dh ; m
[heap]:00F72032 db  61h ; a
[heap]:00F72033 db  6Eh ; n
[heap]:00F72034 db  20h
[heap]:00F72035 db  52h ; R
[heap]:00F72036 db  65h ; e
[heap]:00F72037 db  63h ; c
[heap]:00F72038 db  72h ; r
[heap]:00F72039 db  75h ; u
[heap]:00F7203A db  69h ; i
[heap]:00F7203B db  74h ; t
[heap]:00F7203C db    0
</code></pre><p>.text:0000000000403C73 add [rbp+var_C], 0</p><p>ammo patch</p><p>.text:000000000040396F add [rbp+var_4C], 1</p><hr><h1 id=6---payloaddll>6 - payload.dll</h1><p>Used x64dbg for this instead of IDA.</p><p>if edx == 1</p><p>000007FEF55862 | E8 97 06 00 00 | call payload-olly.7FEF55868B8 |</p><h2 id=call-payload-olly7fef55868b8>call payload-olly.7FEF55868B8</h2><p>Anti-debugging?</p><p>000007FEF55868E4 | FF 15 96 97 00 00 | call qword ptr ds:[&lt;&GetSystemTimeAsFileTime>]</p><p>rbp+10 = GetSystemTimeAsFileTime</p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724397(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724397(v=vs.85).aspx</a></p><p><strong>Rage Quit</strong></p></div><footer><p class=meta><span class=categories>Tags:
<a class=category href=http://parsiya.io/tags/ctf>CTF</a></span></p></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#ida>IDA</a><ul><li><a href=#sub_401121>sub_401121</a></li><li><a href=#sub_4011e6>sub_4011E6</a></li><li><a href=#after-sub_4011e6>After sub_4011E6</a></li></ul></li></ul><ul><li><a href=#in-ida>In IDA</a><ul><li><a href=#sub_1015270>sub_1015270</a></li><li><a href=#sub_1015310dllbase-0x63d6c065>sub_1015310(Dllbase, 0x63D6C065)</a></li><li><a href=#sub_1014e20>sub_1014E20</a></li><li><a href=#back-to-sub_1014e20>Back to sub_1014E20</a></li><li><a href=#pe-header-detour>PE Header detour</a></li><li><a href=#back-to-sub_1014e20-1>Back to sub_1014E20</a></li><li><a href=#sub_10146c0>sub_10146C0</a></li><li><a href=#sub_1014670>sub_1014670</a></li></ul></li></ul><ul><li><a href=#recon>recon</a><ul><li><a href=#strings>Strings</a></li><li><a href=#file>file</a></li><li><a href=#ldd>ldd</a></li><li><a href=#nm>nm</a></li><li><a href=#readelf>readelf</a></li><li><a href=#strace>strace</a></li><li><a href=#ltrace>ltrace</a></li></ul></li><li><a href=#detour-to-function-calls-in-x64>Detour to function calls in x64</a><ul><li><a href=#linux>Linux</a></li><li><a href=#windows>Windows</a></li></ul></li><li><a href=#remote-debugging-with-ida>Remote debugging with IDA</a><ul><li><a href=#call-sub_406c85>call sub_406C85</a></li><li><a href=#read-input>Read Input</a></li><li><a href=#call----sub_4035300008087808087800>call sub_403530(0008087808087800)</a></li></ul></li></ul><ul><li><a href=#call-payload-olly7fef55868b8>call payload-olly.7FEF55868B8</a></li></ul></nav></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2021 Parsia-Clone - <a href=http://parsiya.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/>Hugo-Octopress</a> theme.</p></footer></body></html>